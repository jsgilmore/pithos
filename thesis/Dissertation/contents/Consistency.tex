\chapter{State Consistency}
\label{chp:CONSISTENCY}

In order to design a state management and persistency architecture for P2P MMVEs, the requirements of such an architecture should first be understood. State management and persistency form part of the state consistency architecture of an MMVE. The requirements of the state management and persistency architecture, therefore, depends on what the state consistency architecture requires of it.

The role of this chapter is to describe the state consistency architecture in which the state management and persistency architecture will exist. The chapter provides a broad overview of consistency architecture and also introduces a novel generic state consistency model that may be applied to both C/S and P2P network architectures to achieve state consistency in an MMVE. Classic state consistency architectures are also presented along with a discussion of how they fit into the generic architecture and their various advantages and disadvantages. Finally, the chapter presents an overview of the prevalant consistency model for P2P MMVE and discusses implementations of the various sections as they relate to the generic consistency model.

\section{The virtual environment}

A virtual environment (VE) can be characterised by its \emph{environment state}. When discussing how to segment environment state, it is sometimes easier to speak in terms of \emph{objects}, since they are separable. For the purposes of this work, objects are entities with both state and logic, which means they consume both storage space, as well as computing resources. Objects can also produce events, which should be sent to other objects. When this definition is used, NPC objects may be classified as a specific type of object, which forms part of the global environment state.

Both mutable and immutable objects exist. Immutable objects are those that cannot be altered, for example: rocks, hills and trees. Mutable objects are those that can be altered, for example: NPCs, chests and doors. What objects are mutable is a design decision made by the VE designer, depending on the VE requirements. The environment state includes all positions, health and other attributes of all avatars, NPCs and other objects in the VE.

Mutable objects may further be divided into ephemeral and permanent objects. Ephemeral objects need only be available for certain times, such as a player's (user agent's) \emph{avatar}, when that avatar is online. Permanent objects should remain in the virtual world, whether the user who owns it is on-line or off-line, such as a virtual house.

\emph{Agents} are defined to be some form of intelligence that can interact with the virtual environment and generate actions. An \emph{avatar} is an agent's representation in the virtual environment. It is the form the agent assumes while in the virtual world.

User agents are users that connect to a VE and control their avatar through some external input/output interface and non-user agents are AI scripts that control an NPC avatar. It is assumed that a single user agent is tied to a specific node in the network. Non-user agents can be hosted on any node and the hosting is an implementation of distributed computation, discussed in Section \ref{distributed_computation_requirement}. Both user and non-user agents may interact with the virtual world. When no distinction is required, the generic term ``agent'' is used.

On a physical level, each computer that executes a virtual environment (VE) is executing a copy of the virtual environment. This is because a computer can only operate on what is stored in its primary memory. Because computers cannot access each other's primary memory banks, the necessity of multiple object copies is created. The existence of multiple object copies necessitates an object consistency model.

In MMVEs, each computer uses the information of the virtual environment, stored in memory, to display the virtual environment to the user. The user makes decisions based on what is displayed and the executed operations on the environment. These operations can effect change in the environment and this change has to be communicated to all other entities capable of interacting with the environment. The fact that users operate on a local version of the environment and that the environment should appear the same to all users requires state consistency mechanisms.

\section{Environment change scenarios}
\label{environment_change_scenarios}

In a VE, three main actions should be possible concerning the environment state. It should be possible to add new objects to the virtual environment, an agent should be able to discover objects in its AoI and an agent should be able to alter mutable objects in the virtual environment through its actions.

\subsection{Object creation flow}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=115mm 221mm 184mmm 278mm, height=0.5\textwidth]{generic_consistency_graphic}
 \caption{Diagram showing the flow of messages in the network, when an agent creates an object in the virtual world.}
 \label{fig_object_create_graphic}
\end{figure}
%
Figure \ref{fig_query_flow_graphic} illustrates the process of an agent creating a new object and that object being stored on some authoritative node. The figure shows both the virtual environment and the network. Agent 1 creates an object in the virtual environment. For that object to remain in the virtual environment, a node has to be selected to store the authoritative version of the object. In the network, creating an object translates to the node that houses Agent 1, to create Object 1, and select a node (Node 2) to store the authoritative version of Object 1. Once Object 1 has been created in the virtual environment, all other agents that can perceive the new object should be informed of its existence.

For an agent to perceive an object, the object should be within its AoI. When Node 2 therefore stores the authoritative object, it should discover which nodes can perceive the object and then send updates to those nodes informing them of the new object. In the example in Figure \ref{fig_query_flow_graphic}, Agent 2 can perceive Object 1, which means Node 2 must inform Node 3 of the existence of Object 1, using an object update. Node 3 then receives the object update and adds a non-authoritative version of the new object to its non-authoritative object store. The display of Agent 2 should then be updated to display the new object.

\subsection{Range query flow}
As an agent moves through the virtual environment, it should discover new objects that enter into its moving AoI.

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=78mm 148mm 128mmm 208mm, height=0.5\textwidth]{generic_consistency_graphic}
 \caption{Diagram showing the flow of messages in the network, when an agent queries its AoI for objects in the virtual world.}
 \label{fig_query_flow_graphic}
\end{figure}
%
Figure \ref{fig_query_flow_graphic} illustrates the process of an agent discovering new objects in its AoI. As Agent 1 moves through the virtual environment, it has to query nodes that house authoritative versions of objects in its AoI. Node 1, containing Agent 1, has to determine which nodes contain objects that exist within Agent 1's AoI. For the example shown, Node 1 knows that Node 2 contains an object that is located within the AoI of Agent 1. Node 1 sends a query, also called a range query, to Node 2 informing Node 2 of Agent 1's AoI. Node 2 checks which objects it houses that exist within Agent 1's AoI. Node 2 then informs Node 1 of Object 1, which is the only object in Agent 1's AoI.

The agent performing the queries might have to query multiple nodes and the queried node may return multiple objects.

\subsection{Event-update flow}
\label{event_logic_update}

Agents are not allowed to alter the state of an object in the virtual environment directly, since this leaves the VE open to abuse. To alter the state of objects in the VE, the event-update cycle is used.

\subsubsection{Terminology}
\emph{Events} are generated by agents and can be thought of as actions taken by those agents, where agents can be humans or artificial intelligence (AI) scripts. These include casting a spell, using an item or walking.

\emph{Environment logic} is applied to events to determine what updates should be applied to the environment state. Environment logic is thus a ``think'' function, which determines how the environment should change as a result of an event. Another way to think about environment logic is to see it as the environment rules.

An agent casting a spell might cause another agent's health to be reduced, her own health to be increased or a monster to spawn. When an agent is walking, the logic will cause the agent's position to update at the agent's walking speed.

Environment logic communicates how the world should change via \emph{state updates}. State updates are the incremental changes that specify how the environment state should change.

An object exists in two forms: the \emph{authoritative object} and the \emph{non-authoritative object}. The state of the authoritative object is considered to be the true state or absolute state. Copies of the authoritative object can be made, but these copies are all non-authoritative objects. If a discrepancy occurs between an authoritative object and a non-authoritative object, the state of the authoritative object is considered to be the true state. The work of the consistency mechanism in the VE is to ensure that all non-authoritative object states follows the authoritative object state within a time frame that is reasonable for the particular VE and the particular type of object.

Authoritative objects are the objects traditionally housed on the server in the C/S based MMVEs. All clients obtain replicas of these objects (termed the non-authoritative versions) and duplicate them locally in order to perform low latency computations. An example would be an NPC monster. When agents perceive the monster in the virtual world, a duplicate of the NPC objects is sent to the agent's computer for display purposes. When another agent attacks the NPC, the change in health will be computed at the server and an update is then sent in order to ensure consistency between authoritative and non-authoritative objects.

\subsubsection{Motivation}

It is impossible for multiple object states to always be consistent, because of the finite time taken to disseminate an object update that has occurred. A well designed object consistency model should not allow conflicting changes to local copies of object states.

An example of conflicting change is one avatar in a virtual game world dealing five damage to another avatar with five health. When the damage is dealt, the target avatar is killed. If, however, the avatar drank a potion that gives it some health, the damage dealt by the first player would not kill him. The state of the player being dead and the player being alive is not possible at the same time.

To overcome the difficulty of conflicting states, it was found that nodes participating in a VE should not be able to update the environment state directly. Nodes should rather express the effect they would like to have on the virtual world in terms of actions (events) and all nodes actions should then be combined by a third, centralised party, which then updates the state of the VE according to the combined causal actions of all nodes in the VE, to ensure that conflicts cannot occur. A disconnect is, thereby, created between the actions that can be performed on objects and the effect that the actions can have on objects. This is called the event-update cycle, also called the  ``request-process-update-display sequence'' \cite{Hu_voronoi_IM}.

In P2P MMVEs there still exists a need for an authoritative object, but no centralised location exists to store that object. For each authoritative object, a node is selected to store that object and acts as arbitrator for events operating on that object. That node is termed the authoritative node for the specific authoritative object it houses.

It should be noted that in this work, a node refers to a computer that is connected to a network, and a peer refers to a computer that is connected to a P2P network. The term ``node'' can, however, also be used to mean ``peer'', since  practically, there is no difference between a computer connected to a C/S network and one connected to a P2P network, except for the software that it executes. The term peer is used to clarify that what is talked about is specific to a P2P network.

\subsubsection{Description}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=28mm 221mm 96mmm 278mm, height=0.5\textwidth]{generic_consistency_graphic}
 \caption{Diagram showing the flow of messages in the network, when an agent generates an event that updates an object in the virtual world.}
 \label{fig_event_update_flow_graphic}
\end{figure}

Figure \ref{fig_event_update_flow_graphic} depicts the flow of events and updates in response to the generation of an event by some agent.

In Figure \ref{fig_event_update_flow_graphic}, Agent 1 generates Event 1 at the remote location shown in the virtual environment. To maintain generality, events are defined to possess areas of effect (AoEs). An event's AoE determines which objects are in range to be potentially affected by an event. When an event's AoE encloses an object, that object is in range to be affected by the event. Whether the object is affected by the event, will be determined by the environment logic housed on the authoritative node.

In Figure \ref{fig_event_update_flow_graphic}, Event 1 affects Object 1. Node 1, housing Agent 1, therefore has to determine which objects are affected by an event that it generates. It has to determine on which nodes those objects are housed and send the event to those nodes. In this example, only Object 1 is affected by Event 1. Node 1, therefore, sends Event 1 to Object 1's authoritative node (Node 2).

Determining which objects are affected by an event is termed \emph{event interest management}. Delivering the event to the authoritative nodes of the affected object is termed \emph{event dissemination}. \footnote{It should be noted that designs exist that use multiple authoritative objects, for example the event-based consistency model described in Section \ref{classic_event_based}, but that more research focus has been placed on consistency architectures where every object only possesses a single authoritative object, such as the update-based consistency model described in Section \ref{classic_update_based}.}

When Event 1 arrives at Node 2, containing Object 1, the event is placed in a event queue in an order based on the time each event occurred in. The process of determining which order events have to be processed in is called \emph{event ordering}, since many events will be arriving at an object's authoritative node from multiple agents simultaneously.

After event ordering has been performed, environment logic is applied to determine how a specific event will affect a specific object. To determine possible updates, that state of other objects might also have to be taken into account. An example is firing at an agent through a wall. If the thickness of the wall determines how much damage is delivered to the agent, the authoritative node processing the damage to the agent object will have to know the thickness of the wall.

When an event has been translated into a state update, the authoritative object on the authoritative node (Node 2) is updated. The new state of the object should also be communicated with all agents that can perceive the object in the virtual world. An object is perceived by an agent if the agent's area of interest (AoI)  in the VE encompasses the object. Every agent that can perceive an object, requires a non-authoritative copy of that object. Determining which agents should receive object state updates is termed \emph{update interest management}. In the figure, Object 1 is perceived by Agent 2. Node 2, therefore, sends an update to Node 3, the node containing Agent 2. Delivering state updates to the affected agent nodes is termed \emph{update dissemination}.

When the update is delivered to Agent 2, the local object state is updated and the object's new state is displayed to Agent 2 to allow the agent to make decisions and generate events based on the new object state.

\section{Generic consistency architecture}
\label{generic_event_update_model}

In this section, we will discuss the literature where individual modules of the generic framework are implemented, but to our knowledge, no article has been published that presents a comprehensive view of a state consistency architecture. This generic architecture allows us to put the literature regarding state consistency into context and allows us to identify requirements of the authoritative object store from a consistency perspective.

\subsection{Request-response consistency basis}
Since the description of an overarching framework for state consistency was lacking in the literature, we decided to develop such a framework. To develop this framework, the main issues that state consistency has to solve for each of the scenarios discussed in Section \ref{environment_change_scenarios}, were identified:
%
\begin{itemize}
\item Determine the set of nodes that are interested in a generated request (object, query or event).
\item How requests are sent to the set of interested nodes.
\item Determining the correct order of received requests (events).
\item Generating a response (updates or objects) in response to a request (queries or events).
\item Determining the set of nodes that require the generated response.
\item How responses are sent to the set of interested nodes.
\item How the effect of a response is displayed to an agent.
\end{itemize}

Each identified consistency scenario is in the same basic request-response form. The items in parentheses show the possible forms that the specified request or response can take. Using this basic model, the generic consistency model was created that incorporated all scenarios. This model is shown in Figure \ref{fig_event_update_flowdiagram}.

\subsection{Model}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=30mm 85mm 192mm 282mm, width=0.72\textwidth]{generic_consistency_flowdiagram}
 \caption{Flow diagram describing the event-update flow cycle and all steps required, from generating an event to delivering an update, to ensure object consistency.}
 \label{fig_event_update_flowdiagram}
\end{figure}

Three ``flows'' exist, that model each of the query, create and modification scenarios discussed earlier. A flow is initiated by an agent at terminated at an agent. Flows are symmetrical, which means any agent can initiate a flow or be the terminating agent for a flow. Each flow corresponds to the three scenarios discussed in Section \ref{environment_change_scenarios}.

\subsubsection{Agents and generators}

Agents generate three streams of requests, using a query, object or event generator. The requests are sent to the authoritative object hosts.

Agents may be able to build structures, make clothes or construct a variety of mechanisms in the virtual world. The objects that the agent creates in this way should be stored on an authoritative node.

Agents can also interact with the virtual environment and other agents, which are objects themselves. Agents interacting with objects generate events, which have to be sent to the authoritative node.

Lastly, as agents more around in the virtual world, they might query an authoritative node for any new objects that have entered their AoI. This is referred to as a range query and requires the retrieval of all objects within a certain area.

\subsubsection{Display updater and non-authoritative environmental logic and object store}

Some generated events may be of low importance where a malicious creation of the type of event will not give the generating agent any advantage and will not disadvantage other users. For these types of events, processing them locally using non-authoritative environment logic may be sufficient. Locally processing events reduces network traffic, but increases the security risk. Deciding which events will be handled by non-authoritative environment logic and which will be handled by authoritative environment logic is a significant design decision during the MMVE design phase. It is sometimes difficult to know which types of events malicious users will be able to use to break the environment rules.

Some events may be handled by the non-authoritative environment logic module. This module outputs object updates directly to the non-authoritative object store, without generating any network traffic. The non-authoritative object store houses the local copies of objects that an agent uses to perceive its virtual environment.

The display updater module displays the non-authoritative object store objects to the agent. This may be in the form of interfacing with a graphics card to output the information on a computer screen for a user to see, or to make the objects accessible to an AI script.

\subsubsection{Interest management and dissemination}

Interest management deals with finding a set of nodes that might have an interest in a request being generated. Events, objects and queries require some form of interest management.

Event interest management determines which objects will be affected by a generated event and on which authoritative nodes these objects are housed. Object interest management determines on which authoritative node the generated object should be stored. Query interest management has to discover which authoritative nodes contain objects that exist within the specified range.

Event, object and query dissemination deal with how information is sent to nodes after interest management determines which information should be sent (and to which nodes).

\subsubsection{Authoritative node}

All requests generated at non-authoritative nodes are sent to authoritative nodes for processing. Objects received are stored in the authoritative object store.

Multiple nodes, controlling different areas, may receive the same range query and be expected to supply the objects in their respective authoritative object stores that have positions that intersect with the range of the range query.

After receiving events, they are ordered to maintain causality. Object updates are generated from received events. An object update can be considered as some change that should be applied to a known object. Generating an object update, might also require the state of other objects, retrieved from the authoritative object store. Therefore, after the combination of event, object states and environment logic, an update is generated.

The authoritative node, therefore, can create two reply streams: objects and updates. Objects are created in response to queries and sent to the node requesting the objects. Updates are created in response to received events and these updates have to be applied to the object in the authoritative object store, as well to all non-authoritative copies of the updated object.

Update interest management determines which nodes require the generated update, which typically are the nodes whose agents can perceive the object in the virtual environment, and therefore posses non-authoritative copies of the object. Object interest management has to determine which node received a generated object. With a range query, this will merely be the node that sent the query, but other situation might occur where one node requests objects on behalf of another.

Update dissemination delivers a generated update to all nodes that contain local copies of the object. Multiple object updates may be generated for a single event. Any generated update may be delivered to multiple nodes that contain local copies of the object. Object dissemination delivers generated objects to the nodes that requested them.

\subsection{The event-logic-update scenario as the generic scenario}

It should be noted that object queries and object creation can both be implemented as specialised forms of the event-update model. An object query can be implemented as a ``query'' event with an AoE equal to the generating agent's AoI. The environment logic determines which objects are within the event's AoE and state updates containing the complete object can then be sent to the node containing the originating agent.

Object creation can also be handled as an event, where an ``object creation'' event contains the information required to instantiate the required object. The object creation event can then be sent to the applicable authoritative node. The environment logic will process the object creation event, generate a state update containing the new object and respond with that update to the node of the agent generating the object. This is also considered the safer method by which an object can be generated, since the environment logic can ensure that the object is allowed within the confines of the environment rules.

It is therefore sufficient for the generic state consistency model to only contain the event-logic-update flow, but the other two flow were added for clarity. For the range query, it clarifies that the response is always sent to the node generating the query. For the object creation case, it clarifies that the object itself is generated on the non-authoritative node and then sent to the authoritative node, where it is then housed.

\subsection{Discussion}

The flow diagram in Figure \ref{fig_event_update_flowdiagram} shows all steps that should be taken to ensure object consistency. We shall now demonstrate that the flow diagram of Figure \ref{fig_event_update_flowdiagram} is applicable to all known state consistency models of C/S as well as P2P MMVE architectures.

It should be noted that the generic consistency model is developed to fit all consistency architectures. To this end, some modules might be trivial in some consistency architectures, but become non-trivial with others. This is especially true for the C/S consistency model, where only a single server or server cluster exists, as will be described in Section \ref{classic_models}.

The differences between  the various architectures is where the authoritative objects are  housed, and how the authoritative nodes are distributed. In a C/S system, all authoritative objects are housed in the server. In a P2P architecture, authoritative objects can be distributed on a number of nodes, depending on the specific architecture. The various state consistency schemes for both C/S and P2P networks will be reviewed in the next sections.

\section{Classic consistency models}
\label{classic_models}

An overview of the two common models, currently used in MMVEs will be described. The models used in P2P MMVEs are all permutations of these two basic models. The two models are based on the two different network models. These are the fully distributed model, also called the event-based model \cite{p2p_cm_aoe}, and the C/S-based model, also called update-based model \cite{unreal_networking}.

\begin{figure}[htbp]
\centering \subfloat[Event-based (fully distributed)]{\label{fig_p2p_cm}
\includegraphics[clip=true, viewport= 2.5cm 0.5cm 19cm 15cm, width=0.5\columnwidth]{CS_P2P_CMs}}
 \subfloat[Update-based (client/server)]{\label{fig_cs_cm}
\includegraphics[clip=true, viewport= 2.5cm 15cm 19cm 30cm, width=0.5\columnwidth]{CS_P2P_CMs}}
\caption{Consistency models}
\end{figure}

\subsection{Event-based (Fully distributed)}
\label{classic_event_based}


Figure \ref{fig_p2p_cm} shows the fully distributed model. Each node has a copy of the global VE state. Any event that a node generates is sent to all other nodes. Each node processes all events separately and updates its own environment state accordingly. This consistency model is one where there exists multiple authoritative environment states.

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=1mm 129mm 209mm 266mm, width=\textwidth]{generic_to_fully_dist}
 \caption{The event-based consistency model, showing the modules as defined for the generic consistency model. The diagram shows how the generic consistency model may be used to describe the event-based consistency model.}
 \label{fig_generic_to_fully_dist}
\end{figure}
%
Figure \ref{fig_generic_to_fully_dist} shows the event-based model in terms of the modules defined for the generic consistency model. The figure shows two nodes and how they may interact. For the event-based model, each node is both an authoritative and a non-authoritative node, for the purposes of which modules they contain. There also exists no non-authoritative storage, object interest management, object dissemination, update interest management, or update dissemination modules. The authoritative storage module is directly connected to the display updater module.

The event-based model has fallen into disuse over the past few years, because of its lack of scalability and the degradation in responsiveness experienced when high latency nodes are connected due to the event ordering techniques used, as explained in Section \ref{event_based_event_ordering}.

\subsubsection{Event generation and dissemination}

With reference to the generic flow diagram in Figure \ref{fig_event_update_flowdiagram}, user agents access the VE using nodes in the fully connected network. Event generation occurs on nodes.

Event layer interest management is trivial, since all nodes receive all updates. Every node, therefore, requires an up-to-date list of all other nodes in the network. Event dissemination typically makes use of unicast to send all events to all nodes.

\subsubsection{Event ordering}
\label{event_based_event_ordering}

The order in which events are received is the same for all nodes, otherwise the environment states of different nodes may become inconsistent.
Usually some kind of lockstep technique is used to solve this issue \cite{pessimistic_lock_step}. The issue with lockstep is that it reduces the latency to twice that of the node with the highest latency.

Various techniques have been proposed that improves the latency by introducing some deadline before which all events should be submitted. An example of this is the New Event Ordering (NEO) technique \cite{cheat_proof_event_ordering}. Event ordering using deadlines makes it very difficult for a user with a high latency to access an MMVE, because if one user has a higher latency than the others and misses event deadlines, none of her actions will be processed by the other nodes which effectively excludes the user from the network.

An alternative to NEO is a P2P and C/S hybrid scheme, called the referee anti cheat scheme (RACS) \cite{cheating_taxonomy}. The scheme proposes referees, that are similar to the C/S network model, which allow for greater resistance to more types of cheats.

\subsubsection{Environment logic}
Complete environment logic is housed on every node, since every node must be able to apply the logic to translate any event into a state update. The environment logic will determine a set of objects that will be affected by the received event and update the affected objects accordingly.

\subsubsection{Update generation and dissemination}

The environment logic housed on every node generates state updates. These state updates are only used to update the local copies of affected objects, since each node is responsible for keeping its environment state up-to-date.

Update layer interest management and update dissemination is not required, since all affected nodes will have received the event.

\subsubsection{Authoritative object store}

The complete environment state is stored on each node. This is why the event ordering technique employed is important. If an event is received in the incorrect order at one of the nodes, it may cause inconsistency for the authoritative state of that node. Such a situation is difficult to correct. A possible solution is for detection mechanisms to be implemented, where peers exchange object states at regular intervals for comparison. If a peer's state has diverged from the group, a quorum mechanism might be employed to correct the divergence.

\subsubsection{Advantages}
The event-based model works well for strategy games, and was implemented in Age of Empires \cite{p2p_cm_aoe} and Starcraft \cite{starcraft_network_model}.

When latency issues are not present and all users possess reasonable latencies, the event-based model can provide for an high-degree of responsiveness, because no extra latency is added by a server and no extra hop required to send information to a server which then relays it to all clients.

\subsubsection{Disadvantages}
The event-based model is not scalable, since all nodes must connect to all other nodes and all events are transmitted to
everyone. This means that as $N$, the number of nodes in the network increases, the traffic increases with a factor of $N^2$. The security issues of
the P2P network model, on which this consistency model is based, are also present. A degradation of responsiveness is also experienced by all user if one user's
latency is below par, since the lockstep mechanism has to wait for all events to be received for that round to conclude \cite{cheat_proof_event_ordering}.

\subsubsection{Partially connected event-based consistency}
An event-based model that is not fully distributed might be considered, although such a model holds many challenges. Interest management techniques might be used to determine which nodes require updates. A challenge arises when nodes that were not aware of each other come into contact in the virtual world. A merge operation will have to be performed on the two authoritative environment states to ensure consistency. Such a model has not been proposed in practice and significant research will have to be performed into defining a framework that establishes relationships between events to maintain consistency. Such a system might be developed by defining classes of events and their interactions. A linear temporal logic model might then be developed to ensure consistent merging of states.

A partially connected model is not a classic consistency model.

\subsection{Update-based (C/S)}
\label{classic_update_based}

An alternative to the event-based model is the update-based model, shown in Figure \ref{fig_cs_cm}. This model is based on the C/S network model and based on the principle that only the server contains authoritative environment state.

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=28mm 66mm 190mm 262mm, width=0.72\textwidth]{generic_to_cs}
 \caption{The update-based consistency model, showing the modules as defined for the generic consistency model. The diagram shows how the generic consistency model may be used to describe the update-based consistency model.}
 \label{fig_generic_to_cs}
\end{figure}
%
Figure \ref{fig_generic_to_cs} shows the update-based consistency model, showing the modules as defined for the generic consistency model. This model is similar to the generic consistency model itself, introduced in Figure \ref{fig_event_update_flowdiagram}. The only difference is that there exists a single authoritative node, containing all objects and that no interest management is required by the clients, since all queries, objects and events are only sent to the server.

\subsubsection{Event generation and dissemination}
Agents control clients that are able to generate events. As with classic event-based consistency, event layer interest management is trivial, since all events are sent to the server, usually making use of a unicast event dissemination technique. Interest management only becomes non-trivial when the P2P MMVE consistency model is considered in Section \ref{p2p_mmve_state_consistency}. The reasons why these sections exist in a discussion of the classic consistency models is to show that, although trivial, all sections relate to the generic consistency model.

\subsubsection{Event ordering}
\label{cs_event_ordering}

Event ordering is performed server-side, although it is not as critical as for the fully distributed model. If events are processed in different orders by different clients in the fully distributed model, the environment states of the clients will start to diverge and no mechanism currently exists to merge the diverging states.

If event ordering is not performed in the update-based model, the server might execute some events out of the order in which they were generated. The environment state will, however, remain consistent, since the server informs all clients of the environment state once it calculates a new environment state.

\subsubsection{Environment logic}
The environment logic that deals with high risk and high importance events is housed on the server. This allows for simplicity of design and increases system security, since the server can verify any actions performed by a client. Environment logic housed on the clients deal with low risk events that don't require a high level on consistency, for example, movement updates.

\subsubsection{Update generation and dissemination}

The environment logic generates states updates, which is used to update the server's authoritative environment state and is also used to inform nodes able to perceive the updated objects of the object's new state.

Update level interest management is required to determine which clients can perceive the updated objects. Unicast (direct transmission using TCP or UDP) is then used as update dissemination technique to inform the affected clients of the updated object states.

\subsubsection{Authoritative object store}
An authoritative global environment state is housed on the server and a  non-authoritative local environment state is housed on all clients for display purposes.

\subsubsection{Advantages}

\begin{itemize}
\item \emph{Authority}: The server state is authoritative, because if there is a conflict, the server state is always the state to which the system is expected to return. Combining server authority with the fact that the MMVE operator has full control over the server allows the operator to control who may access the server and on what terms.

\item \emph{Security}: The update-based model is secure, since clients cannot influence the state of any other clients and every client's state depends on updates received from the server.

\item \emph{Hardware scalability}: Another reason why the update based model is successful is because it is currently more scalable then the fully distributed model. More hardware can be used to build a more powerful server, which can handle more clients. It should be noted that scaling using hardware is expensive, since large server farms are required to host the VE.
\end{itemize}

\subsubsection{Disadvantages}


All disadvantages of the C/S architecture, as discussed in Section \ref{classic_cs_disadvantages}, are relevant to the update-based model, since the model is based on the C/S network model.
%
\begin{itemize}
\item The main disadvantage is the high cost involved in obtaining and maintaining the computer clusters and server hardware, required to host the VE.

\item When the server fails, the complete VE is off-line. Approaches exist to host the VE on multiple servers, but in this case a ``zone crash'' may still occur where a server hosting a specific region goes off-line. Additional redundancy is possible if backup servers are used, but this further increases costs.

\item Sufficient hardware may be made available to support the VE environment, but the update-based system struggles with dynamic load balancing to cope with large numbers of users flocking to a single area in a short span of time \cite{flocking}.
\end{itemize}

\section{P2P MMVE state consistency models}
\label{p2p_mmve_state_consistency}

Various schemes have been proposed to address the various challenges of P2P MMVE state consistency, but these have mostly occurred in isolation. Each approach focuses on a few of the modules identified in the generic state consistency model presented in Section \ref{generic_event_update_model}, but no approach addressing all modules.

\subsection{Related work}
The most complete implementation of a P2P MMVE state consistency model found was P2P Second Life, although greater emphasis was placed on creating and discovering new objects than updating existing object states \cite{varvello_p2p_second_life}, \cite{Walkad_Varvello}. This might be due to Second Life's focus on object creation, where other MMOGs, for example, World of Warcraft and Eve Online, have less of a focus on object creation and more of a focus on interaction with existing objects. P2P Second Life, therefore, described the object creation and query flows, but did not explain the process of altering existing objects in depth.

The only object alteration described is avatar alteration, called distributed avatar management \cite{Varvello_dist_avatar_management}. A focus was placed on ensuring that every peer is aware of all avatars within the AoI of its own avatar and that all neighbouring avatars remain connected. The process of updating avatar information was not discussed.

What should be noted is that the various areas of state consistency, e.g. interest management, event ordering, state management, and the other areas discussed in Section \ref{generic_event_update_model}, are quite modular, which might allow for the integration of the best schemes in each area into a comprehensive P2P MMVE state consistency model. Therefore, some of the proposed schemes were reviewed to determine the scheme most suitable for integration.

\subsection{Region-based update-based consistency model}
P2P MMVE schemes are based on one of the two classic consistency models described in Section \ref{classic_models}. Although it might seem that the fully distributed model is a better fit for P2P MMVE state consistency, this model has received less attention than the C/S model. The reason for this is partly because of the difficulties in getting the fully distributed model to scale. Usually the fully distributed model makes use of rounds, where users submit events and all user events are executed at the end of a round. In an MMVE with tens of thousands to millions of users, designing the round mechanism to remain scalable is a challenge. Rounds are required, because of the event ordering mechanism that ensures state consistency.

The C/S consistency architecture is applied to P2P MMVEs by distributing authoritative objects. Every authoritative object is maintained by a single peer, that receives all events for the object, applies the environment logic and informs all peers of the generated updates. This effectively creates a C/S consistency model from the perspective of each authoritative object. An example of such a consistency model is the region-based model, which requires that some peers be selected as super peers. Super peers are specialised peers that perform specialised tasks within the P2P network. \footnote{The super peer is selected in some logical way, from the available set of peers and then promoted. Super peer selection in itself is a complex topic that has to deal with determining whether a peer has sufficient resources available and also whether the peer is trustworthy.}

A region is usually created by segmenting the world, with super peers acting as regional servers to all peers in their region. Each super peer receives all events, handles all environment logic and distributes updates to all peers in its region. The super peer also handles state management and persistency for its region, containing NPCs, objects and persistent user data. Clients in the region only house copies of the regional objects and some client logic to update the local copies of objects.

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=2cm 5cm 27cm 16.5cm, width=\textwidth]{region_based_CS_CM}
 \caption{Region-based Client/Server consistency model}
 \label{fig_cs_region_cm}
\end{figure}
%
Figure \ref{fig_cs_region_cm} shows the region-based P2P consistency model. The model is based on the update-based model, but segmented into separate regions. The role of the server is here fulfilled by a super peer.

In the remainder of this section an overview is presented of the different techniques and general trends present in the various areas of P2P MMVEs. The overview does not presume to present an exhaustive list of papers in these areas, rather to place the topic of state management and state persistency in context.

\subsection{Reqeust generation and dissemination}

In P2P networks, each peer contains an agent that represents a user (player). Each agent generates events, queries and objects that have to be transmitted to the required peers.

Classically, application level multicast (ALM) and unicast techniques are the two methods of request dissemination (classically called event dissemination). The specific technique used depends on the grain of the dissemination. ALM is used, instead of router level multicast, because of a lack of general support for this technology at the router level \cite{ip_multicast_deployment_issues}.

ALM is used for coarsely grained interest management techniques, while unicast is used for finely grained techniques. Unicast is not used for coarsely grained techniques, because it is not scalable. For a network containing $N$ peers, $N^2$ messages are exchanges for every user action. ALM, however, significantly increases the message latency in the system, because messages first have to be routed over a structured overlay network. ALM is however preferred over unicast for large numbers of messages, because of the weak scalability of unicast.

An ALM scheme has recently been proposed, that sends updates to locations in the virtual world, rather than to specific users \cite{Ghaffari_Delaunay_churn_mobility}. This removes the need to first determine which peers will be affected by a request, before the request may be transmitted. Another ALM scheme proposed sends messages to the neighbours in the AoI, instead of to all the users in the region \cite{Seeger_area_based_gossip_multicast}. This effectively implements a basic interest management scheme, where only neighbouring users can receive requests.

\subsection{Event ordering}

The presence and complexity of event ordering depends on the consistency architecture on which the P2P MMVE is based. In systems that use the update-based (C/S) model, no literature could be found that addresses the issue of event ordering, since events delivered out of order will not lead to an inconsistent state, as discussed in Section \ref{cs_event_ordering}.

Where distributed architectures are proposed for P2P MMVEs, event ordering is of high importance. Designers of P2P MMVEs make use of the same event ordering mechanisms, as is used in the fully distributed model \cite{hybrid_storage1}.

To support a large number of users using an event-based model, event ordering with the concept of interest has been developed using N-trees \cite{GauthierDickey_ntrees}.

\subsection{Environment logic}

In P2P architectures, the environment logic for all objects have to be housed on all peers, since any peer can be selected to store any object. The environment logic itself is, therefore, usually also distributed as part of the client software. This does not mean that the environment logic cannot change, but any change in environment logic will be in the form of a client patch, which occurs while the application is off-line.

\subsection{Update generation and dissemination}

In P2P MMVEs, update generation is the responsibility the peer containing the authoritative object. When the peer receives an event, environment logic is applied to generate an update. This update is then disseminated to all peers that have local non-authoritative copies of the object. This is similar to the update-based consistency model discussed in Section \ref{classic_update_based}.

\subsection{Update and event layer interest management}
\label{key_challenges_im}

Interest management occurs both in the update and the event layer. For the event layer, the set of peers housing the authoritative object, affected by the generated event, has to determined. For the update layer, the set of peers has to be found which house the agents that will perceive an object update. What is common to both layers is that a message has to be sent to a subset of peers with interest in the message and the interest management mechanism must determine what that subset is.

Thus far, little attention has been paid in the P2P MMVE literature, to whether the interest management in question is developed for the event layer or the update layer. Most discussions implicitly assume a layer and all the descriptions of the algorithm are based around the terminology of that layer. That is not to say that the algorithm itself might not be traversable to the other layer, just that this is not discussed.

Interest management is used to determine the smallest amount of information that a peer requires, in order to present an accurate representation of the world to users. In consistency terms, it provides a means to determine which non-authoritative objects require updates of the authoritative object. The idea is not specific to P2P MMVEs and was already formally suggested in \cite{First_IM} and later with greater focus on a distributed environment in \cite{Whang_agent_based_IM}.

The main idea is that a user has a limited visual range and area around the user in which it can interact with objects. The user requires update information of all objects in this area, called the user's Area of Interest (AoI). AoI calculations also rely on the fact the a user's direction and velocity of movement cannot change instantaneously and are bounded in magnitude.

Extensive research has been done into solving AoI problems and a comparison of techniques can be found in \cite{Boulanger_IM_compare} and \cite{IM_and_ED_survey_Krause}. The solutions range from aura/nimbus \cite{Benford_spatial_IM} to publish/subscribe  \cite{mercury_publish_subscribe} to Voronoi based models \cite{Hu_voronoi_IM},  \cite{Buyukkaya_voronoi_state_management} to hybrid models \cite{hybrid_IM}, \cite{MOPAR}, \cite{fan_mediator_paper}.

Generally, interest management solutions can be divided into coarsely or finely grained solutions, although the hybrid models, especially MOPAR, seem to have gained greater popularity because they seem to have all the benefits of the two solutions and little of the drawbacks \cite{MOPAR}. MOPAR has been shown to perform better than either a finely grained technique or a coarsely grained technique.

Coarsely grained solutions usually divide the virtual environment into multiple regions and when a user enters a region, it subscribes to that region's events. This is called the region-based publish subscribe model \cite{Fan_deisgn_issues_p2p}. All users in the region then receive the region's events, even for users not in their AoI.

Finely grained techniques create groups of agents based on their AoIs. Groups of interacting agents directly exchange information, so all agents only receive information that is relevant to them. This has been termed the spatial model \cite{Fan_deisgn_issues_p2p}. The grain of the solution in turn determines the type of event dissemination that should be used, as described later in this section.

Another example of finely grained interest management, making use of frontier sets, was presented in \cite{IM_frontier_sets} and implemented in Quake 3. By using Frontier Sets, it is possible to describe an area in which an agent may move, where no other users will require updates of that movement. Conversely, a set of other users that require movement updates from a specific user is also given by the frontier set.

MOPAR partitions the VE into hexagonal regions and appoints ``home'' peers to act as bootstrap peers for each region. A home peer of a region is that peer whose ID is the closest match the the region ID. This allows any peer to find the home peer for a region. A master peer is then selected for every region, whose function it is to inform slave peers of new neighbours. All slaves peers in a region register at their region's master peer.

Slave peers send direction and velocity updates to their masters. Masters communicate directly with other masters if a peer is about to enter their region. Masters inform their slaves of a new neighbour. Slaves communicate directly with each other, once identified by a master.

Interest management is a mature area of research, with many proposed schemes. It is one of the areas in P2P MMVE research that has received the most attention.

\subsection{Authoritative object store}

State persistency is treated as a sub domain of state consistency and is similar to state management, as discussed in Section \ref{management_persistency_def}. State models define where and how the authoritative objects are stored. It is assumed that non-authoritative objects are always stored in the primary memory of the clients that immediately require the information contained in the authoritative object.

The most mature state management model reviewed is that of P2P Second Life, which was discussed in Section \ref{intro_related_work} and will be further discussed in Section \ref{super_peer_storage_rel_arhcs}.

\section{Conclusion}

This chapter introduced the event-update consistency model that is mostly used in MMVE. From the literature reviewed, a generic process was developed that will ensure state consistency. Classic state consistency models were introduced and it was shown how these models relate to the generic state consistency process. This is followed by a description of state consistency for P2P MMVEs. It was shown how the models used are all based on the classic consistency models. Some research into every area of P2P MMVE state consistency was discussed to enable the reader place the research of this work into perspective.

In this chapter it was shown that the field of P2P MMVE state consistency is a growing one, already containing many significant contributions. The purpose of this chapter was to place contributions in the field of P2P state consistency into perspective, to structure the literature concerning state consistency. It is believed that this structure will allow for more complex state consistency designs, by making use of the modular approach proposed in this chapter.

A thorough investigation into state consistency has now been performed. It was found that significant work still remains in the authoritative object store. Maintaining the authoritative object store is termed state management and state persistency. These techniques will be reciewed in the following chapter. P2P storage is classified into multiple types found in the literature and metrics are identified by which to judge the various storage schemes. This is done to work towards a point where our own novel state management and persistency architecture can be proposed.
