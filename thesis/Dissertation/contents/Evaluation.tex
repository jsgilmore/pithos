\chapter{Pithos Evaluation}
\label{chp:EVALUATION}

The purpose of this chapter is to verify that Pithos meets the design requirements set out in Chapter \ref{chp:DESIGN} and to compare Pithos to overlay storage. Following the discussion of the Pithos design and implementation, the performance of Pithos will now be presented, along with a comparison of Pithos against overlay storage.

The overhead (bandwidth usage), reliability and responsiveness of Pithos will be evaluated together, since the one influences the other as will be shown. The fairness, scalability and security of Pithos will then be evaluated separately.

\section{Simulation setup}
\label{simulation_setup}

Since Pithos is designed to be a storage solution for P2P MMVEs, it is important that the simulation conditions reflect the network and storage conditions that a typical MMVE experiences. Specifically, the following simulation parameters are important:
%
\begin{itemize}
\item Size of the P2P network (number of peers).
\item Length of simulation.
\item Underlying physical network.
\item Object lifetime distribution (network churn)
\item Storage and retrieval rate.
\item Choice of P2P overlay.
\item Size and time-to-live (TTL) of objects being stored.
\end{itemize}

\subsection{Size of the P2P network}
For the results shown, 2500 peers, 100 super peers and a single directory server are created at the start of the simulation, simulating a \emph{sufficiently scalable} MMVE, as discussed in Section \ref{scalability_req}.

\subsection{Length of the simulation and storage and retrieval rate}
Each simulation runs for 10,000 seconds, which generates a total of 5 million storage and retrieval requests and an average of 600,000 objects. This is thought to be a sufficient number of requests and objects to generate results with high accuracy.

After a node has joined the network, PithosTestApp starts to generate store and retrieve requests at a rate of one objects every 5 seconds. Storage requests are limited to a total window of 20s. The limit of 20s storage request generation time for every new peer joining the network is to reduce the memory required to store all objects. With the current setup, every simulation run requires 6 gigabytes of memory.

\subsection{Underlying physical network}
To be able to simulate Pithos for the large numbers of nodes required, as discussed in Section \ref{scalability_req}, it runs on the simple underlay. Pithos is dependant on the delay characteristics of the lower level protocols, but the CAIDA and Skitter measurements capture these quantities in their measurements. The reasons why the underlying network shows certain delay characteristics are not important. A focus is also not currently placed on the effects of transient background traffic flows in the Internet architecture on which Pithos executes.

The simulation uses a channel bandwidth of 10 Mbps. Pithos has also been successfully tested for a 1 Mbps link. Results of the 1 Mbps link are similar to the 10 Mbps results. The bandwidth requirements of Pithos is also evaluated in this chapter.

\subsection{Object lifetime distribution}
For each node in the simulation, a lifetime is sampled from some statistical distribution. The two distributions considered were the exponential and Pareto distributions, which are two distributions that are regularly used in reliability engineering \cite{rausand2004systemreliability}. For most experiments, exponential peer lifetimes were used, since this distribution places a heavier load on the storage system, because of the heavy tail of the Pareto distribution. The load is increased, because if more peers have shorter lifetimes, objects will have shorter expected lifetimes, which decreases the reliability of the system. A heavy-tailed distribution contain more peers that live longer, which increases object lifetime and, therefore reliability.

The Pithos simulation has, however, been successfully evaluated using Pareto lifetime distributions and an experiment is performed in Section \ref{repair_results}, to show the differences in performance between the two distributions.

Node lifetimes represent how long users spend in the VE. It has been found that these times vary greatly between the type of VE. Mean playing time in WoW, for example, has been measured as 168 min (10080s) \cite{wow_gameplay_hours}, with players staying for at least an hour and usually not longer than five hours per session. In Second life, 50\% of users stay connected for less than 10 min (600s), 15\% stay connected for 100 min or more and 5\% of users stay connected for more than 10 hours \cite{Varvello_life_in_second_life}.

Unless otherwise states, peers with 1800s mean lifetimes are used, which was chosen to be somewhere in the mid range of the two games evaluated.

\subsection{Overlay}
In the results shown, Chord was used as the P2P overlay, mainly due to its faster simulation time, compared to Pastry. On a quad core Intel i5 2.66 GHz processor, Pithos using Chord takes 4 hours to simulate and Pithos using Pastry takes 10 hours to simulate. Pithos has, however, also been successfully tested with Pastry and Kademlia and results are similar, as shown in Section \ref{overlay_results}.

The specific overlay used is not as important when evaluating the performance of Pithos, since Section \ref{group_probability_results} shows that the performance of overlay storage and group storage are independent and that there exists a linear relationship between overlay storage and group storage as a function of how many in-group requests are sent, when evaluating the overall Pithos performance.

\subsection{Object size, TTL and replication}
An object size of 1024 bytes was chosen to be much larger than Quake 3 game objects without delta encoding, as seen during the development of Donnybrook \cite{Bharambe_Donnybrook}, since Pithos is designed for the low latency storage of small game objects.

Objects have a TTL of 300s and group storage stores six object replicas and retrieves either one, four or six depending on the storage method and experiment. The number of replicas and object TTL was chosen to ensure that objects will remain in the system with a high probability, without the need for repair. The theoretical work presented in Chapter \ref{chp:MODELLING}, allowed us to predict expected object lifetimes under the conditions presented and to know that with a TTL of 300s and six replicas, there is a high probability that the objects will be in the system for the full 300s.

The overlay storage module stores 4 object replicas and always requests 4 replicas in parallel, similar to Pithos's parallel retrieval. Overlay storage expects more than half of the requests to be identical, before success is reported.

\subsection{Measurement of metrics}
\label{metric_measurement}

Some key metrics that will be used to show performance in this chapter are: bandwidth usage, reliability and responsiveness. How these metrics are measured will now be described.

\subsubsection{Reliability}
Reliability is measured as the ratio of successful responses received, to the total number of requests sent. Storage reliability measures the ratio of successful storage requests. Retrieval reliability measures the reliability that an object that was successfully stored can be successfully retrieved. Reliability is, therefore, given by
%
\begin{equation}
\textrm{reliability} = \frac{\textrm{successful responses}}{\textrm{total requests}}
\end{equation}

\subsubsection{Responsiveness (latency)}

Responsiveness is measured as the round trip latency of a request in seconds.  In other words, the time it takes, since a request is generated, until a response is received. For the latencies measured in all the results shown, the widest 95\% confidence interval for all means measured is 0.3ms, which gives an idea of the precision of the results presented.

\subsubsection{Bandwidth usage}

Bandwidth is measured in bytes per second (Bps) and measures the amount of data transferred per unit of time. In the simulation, a distinction can be made between the data used for group storage and the data used for overlay storage. These two entities are two different modules in the Oversim simulation. Every module measures the amount of data that it sends and received over UDP. This data is used when measuring group and overlay storage bandwidth. It, therefore, includes both the object data as well as any overhead.

To compare overhead, the sizes of objects received from PithosTestApp is used as a metric of usable data entering and exiting the system. This definition of overhead ignores any packet headers or response message sent to the higher layer that does not contain an object. Overhead is then given by:
%
\begin{equation}
\textrm{overhead} = \frac{\textrm{Pithos UDP bps - object bps}}{\textrm{Pithos UDP bps}}
\end{equation}

\section{Reliability, responsiveness and bandwidth}

Firstly, the reliability and responsiveness of storage and retrieval performance of Pithos and overlay storage are evaluated. The purpose of this section is to establish the baseline of Pithos performance under a basic simulation setup. Therefore, no object repair is performed and no malicious users exist. The network, however, still contains churn.

It is expected that this experiment will show the high reliability and low storage and retrieval responsiveness of Pithos. The reliability of Pithos should be at least the same as overlay storage, while the latency should be significantly lower. This experiment is also used to compare the different storage and retrieval methods implemented in Pithos. The best performing methods will be used in subsequent experiments.

\subsection{Overlay storage}
\label{overlay_results}

In this evaluation chapter, Pithos will mainly be compared with pure overlay storage, as well as the different implemented methods of group storage. Overlay storage was chosen as a comparison, because as discussed in Section \ref{overlay_storage}, many P2P implementations mention using overlay storage as a solution for state management and state persistency.

Overlay storage requires a routing overlay. Three types are overlays are now evaluated: Chord, Pastry and Kademlia. For Chord, three different configurations are evaluated to show how an overlay's performance may be altered by altering its configuration parameters, especially the time between routing table maintenance. For a brief description and comparison of Chord, Pastry and Kademlia, kindly refer to \cite{overlay_survey}.

For the Chord overlay, the three configurations represent high, medium and low levels of reliability and bandwidth requirements respectively. The main parameter modified to achieve these varying levels of responsiveness and reliability is the Chord finger (routing) table update time. The update time determines how up-to-date the Chord finger tables are and by extension, how up to date Chord's view of the network is.

\subsubsection{Configuration parameters}

The configuration parameters of the Chord, Pastry and Kademlia overlays used, are given in Appendix \ref{chp:OVERLAY_CONFIG}. For Chord medium, Pastry and Kademlia, the Oversim default values were used.

\subsubsection{Performance}

Table \ref{tab_overlay_rel_resp_results} shows the reliability, responsiveness and bandwidth of overlay storage for various types of routing overlays. Because of how the settings were defined, high has the highest storage reliability of 98.31\%, medium has a storage reliability of 96.9\% and low has the lowest storage reliability of 79.08\%. High also possesses the higher retrieval reliability of 93.65\%, medium has a retrieval reliability of 93.20\% and low has the lowest retrieval reliability of 62.16\%.
%
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{Entity}       & \multicolumn{2}{c|}{Reliability (\%)}    &\multicolumn{2}{c|}{Responsiveness (s)}& \multicolumn{2}{c|}{Bandwidth (Bps)}\\
\cline{2-7}
             &store & retrieve & store & retrieve     & in & out\\
\hline
Chord high   & 98.31 &93.65 & 1.217&1.745  & 2175&2189 \\
Chord medium & 96.9  &93.20  & 1.214&1.582  & 1183&1197\\
Chord low    & 79.08 &62.16 & 1.245&2.071  & 301 &314\\
Pastry       & 98.97 &94.90 & 0.625&1.182  & 1979&2088\\
Kademlia     & 45.53 &35.13 & 0.908&4.604  & 512 &498\\
\hline
\end{tabular}
\caption{Evaluation of overlay storage responsiveness and reliability for various Chord parameter settings.}
\label{tab_overlay_rel_resp_results}
\end{table}

What is also clear from Table \ref{tab_overlay_rel_resp_results} is that for low reliability storage, it takes a longer time to retrieve an item, compared to medium or high storage, which further highlights the importance of high overlay reliability.

When comparing Pastry to Chord, the performance of Pastry is higher than that of Chord. This may be seen when comparing the Chord high configuration with Pastry. Pastry has a higher reliability and improved responsiveness, using less bandwidth than Chord. Kademlia has reduced performance, but also required less bandwidth than the two other overlays.

The reliability of the overlays presented here can be adjusted at the cost of bandwidth. An overlay can be made more reliable, but will then require more bandwidth, because increased reliability is achieved by in increasing the rate at which the routing tables are updated.

\subsection{Pithos performance}
\label{pithos_resp_rel_results}

The results presented in Tables \ref{tab_pithos_storage_results} and \ref{tab_pithos_results} are for a medium overlay storage configuration as described in Section \ref{overlay_results} and where all requests were objects in the group.

Tables \ref{tab_pithos_storage_results} and \ref{tab_pithos_results} present the reliability and responsiveness results for the various Pithos storage and retrieval methods discussed in Sections \ref{pithos_store} and \ref{pithos_retrieve}. Both safe and fast storage and fast and parallel retrieval are compared. It should be noted that because Pithos is a group/overlay hybrid storage, its performance depends on the underlying group and overlay performance.

It does not make sense to evaluate retrieval performance apart from the storage method used, since the storage method determines whether objects are stored successfully. Therefore, for each storage method in table \ref{tab_pithos_storage_results}, it firstly shows the performance of only the specific storage method. The retrieval performance is then evaluated, taking into account the storage method used.

What will also be shown in this section is that overlay storage requires significantly more bandwidth than Pithos group storage.

\subsubsection{Storage}
\begin{table}[htbp]
\centering
\begin{tabular}{|c|l|l|}
\hline
\multirow{2}{*}{Storage method} & \multirow{2}{*}{Reliability (\%)} & Responsiveness \\
               &             & mean (var.) (s) \\
\hline
Safe    &  97.05  &   1.554 (3.178)  \\
Fast    &  100     &   0.0665 (0.00593) \\
\hline
\end{tabular}
\caption{Responsiveness and reliability of Pithos's safe and fast storage.}
\label{tab_pithos_storage_results}
\end{table}
%
Table \ref{tab_pithos_storage_results} shows that when fast storage is used, a reliability of 100\% is achieved, which is higher then the 97.0\% reliability of safe storage. The real reliability is not actually higher, but because fast storage only waits for a single successful response before reporting success, it reports more successful storages. Safe storage, on the other hand, ensures that a majority of replicas were successfully stored before reporting success.

Fast storage will still report success, even if the majority of files were not successfully stored. Fast storage is thus trading reliability for responsiveness. If the underlying network is sufficiently reliable that there is a low probability of any request failing, fast storage is more appropriate than safe storage.

Fast storage can also be extended to retry a failed storage request and to select a new destination for the request. If the failure probability is low, the extension should have a negligible effect on responsiveness, while increasing reliability.

The advantage of fast storage over safe storage is its higher responsiveness of 0.0488s, compared to safe storage's 1.576 s. This means that data are available for retrieval 32 times faster with fast storage compared to safe storage.

\subsubsection{Retrieval}

\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|l|l|l|}
\hline
Storage & Retrieval & \multirow{2}{*}{Reliability (\%)} & Responsiveness & \multicolumn{2}{c|}{Group bandwidth (Bps)} \\
\cline{5-6}
   method      &     method       &             &mean (var.) (s)& in&out\\
\hline
Fast           &   Fast           &   99.70    &  0.192 (0.181) & 187&183\\
Safe           &   Fast           &   99.77    &  0.189 (0.160) & 183&180\\
Fast           &   Parallel       &   99.98    &  0.0846 (0.051)& 784&735\\
Safe           &   Parallel       &   99.98    &  0.0859 (0.053)& 798&749\\
\hline
\end{tabular}
\caption{Responsiveness and reliability of fast and parallel retrieval for safe and fast storage.}
\label{tab_pithos_results}
\end{table}
%
Table \ref{tab_pithos_results} shows the results of fast and parallel retrieval for fast and safe storage respectively. Interestingly, fast retrieval for fast storage performs only marginally worse (99.70\%) than fast retrieval for safe storage (99.77\%). It performs worse, because objects that were incorrectly reported as successfully stored by fast storage, was in fact not stored correctly. Fewer replicas than required might have been stored, which makes the object more sensitive to network churn. If fewer replicas than required are stored, the object will not live as long as other objects that have more replicas.

When fast retrieval attempts to retrieve an object stored with fewer replicas, there is a greater chance that the object has been destroyed, compared to an object that had more replicas initially stored. The request is then unsuccessful. The same is true for parallel retrieval for fast storage, compared to parallel retrieval for safe storage. Safe storage leads to an increase in retrieval reliability at the cost of longer delay before storage success is reported.

Comparing parallel retrieval to fast retrieval (both using fast storage) leads to similar results as the comparison of parallel retrieval to fast retrieval (both using safe storage). Parallel retrieval is both more reliable and responsive than fast retrieval. Parallel retrieval (99.98\%) is more reliable than fast retrieval (99.70\%), because of more requests being sent, which increases the probability that the request arrives at a node that is not about the leave the network.

The responsiveness of parallel retrieval (0.0876 s) is also higher than fast retrieval (0.196s), because fast retrieval uses the first received response. The responsiveness of a retrieval request depends only on the fastest received response. If more retrieval requests are sent, the expected response time decreases because more links are now used. In other words, if more links are used, there is a higher probability of at least one link being faster than the others.

It should be noted that the Pithos responsiveness is highly dependant on the underlying network performance. The fast storage, fast retrieval performance of 192ms might seem slow, but is a function of the connectedness and responsiveness of the underlying physical links. Oversim models a global scale network as the underlying physical network, which means that the Pithos responsiveness should be seen in the context of operating in a network, distributed across the world. In a later experiment (Section \ref{lan_retrieval}), the Pithos performance for fixed network responsiveness in a local area network (LAN) environment with 1ms latencies is presented. The experiment shows the average Pithos retrieve latency reduced to 1.6ms.

For subsequent experiments, fast storage has been adopted. The factor 32 increase in responsiveness is seen to outweigh the factor 1.029 decrease in performance.

The question whether fast or parallel retrieval is preferred depends on the implementation environment. The reliability of fast retrieval will suffer if malicious nodes are present in the network, since fast retrieval sends the first received object to the higher layer. This leaves no time to compare objects received from multiple nodes. A fairer comparison of fast retrieval to parallel retrieval must also take bandwidth requirements into consideration.

\subsection{Bandwidth requirements}
\label{bandwidth_requirements}

Bandwidth requirements have to be taken into account to enable a fair comparison of the different Pithos storage and retrieval methods as well as to compare Pithos with overlay storage. Table \ref{tab_pithos_results} shows the required bandwidth of Pithos's group storage architecture. Because Pithos is a hybrid storage scheme, its properties depend on the underlying properties of both group and overlay storage modules.

To place the bandwidth usage into perspective, the data sent to Pithos by PithosTestApp and received from Pithos by PithosTestApp should be considered. For the simulation setup as described, 4 bytes per second (Bps) is sent to Pithos and 157 Bps is received from Pithos. The reason why there is less data sent to Pithos, is because of nodes only generating objects for 20s, as discussed in Section \ref{simulation_setup} and retrieval requests being generated during the complete lifetime of a node.

It was found that there is no interaction of group bandwidth requirements with overlay bandwidth requirements and that the two can be evaluated separately. To calculate the total bandwidth required by Pithos, first requires a choice of group storage and retrieval method and then a choice of overlay settings. For the storage and retrieval results shown in Section \ref{pithos_resp_rel_results} a medium overlay storage was used in Pithos. It presented an acceptable reliability, for an acceptable runtime. The more reliable an overlay, the more routing table updated have to be exchanged, which increased simulation time. Simulating Pithos with the medium overlay takes approximately 4 hours, whereas the high overlay takes approximately 12 hours.

It can be seen that ``high'' overlay storage still has a lower reliability than group storage, but for higher reliabilities, overlay storage requires prohibitively large amounts of bandwidth, as shown in Section \ref{bandwidth_requirements}.

\subsubsection{Group storage}
Table \ref{tab_pithos_results} shows that the bandwidth requirements in bytes per second (Bps) for fast and safe storage are similar and that bandwidth usage largely depends on whether fast of parallel retrieval is used. The reason being that parallel retrieval requires multiple retrieve requests be sent out, which has multiple returned object as an effect. In the results shown, six parallel requests were used to request all six replicas stored.

Six parallel requests lead to a factor four increase in required bandwidth. What is interesting is that it does not lead to a factor six increase in bandwidth as expected. This is a combination of two factors.  The first is that a peer might retrieve an object locally and therefore require no bandwidth for that retrieval. The second has to do with the average number of object replicas under network churn. Initially, when an object is stored, six replicas are stored in the group. During the 300s lifetime of the object, some replicas are removed due to nodes leaving the network. Objects in a group, therefore, have an average number of replicas that are less than what was originally stored. Therefore, even though six retrievals are requested, only four replicas on average exist in the network and therefore only four replicas can be retrieved.

It should be noted that this does not influence group reliability, since all peers are aware only of the objects that do exist in the group. Failures can only occur when a peer sends a retrieval request to a target peer, as the target peer leaves the network.

\subsubsection{Overlay storage}
Table \ref{tab_overlay_rel_resp_results} also shows the large bandwidth requirement of overlay storage, compared to group storage, requiring 1183 Bps inbound and 1197 Bps outbound to function correctly. The low setting required a lot less bandwidth, but also only has a reliability of 62.16\% and a responsiveness of 2.071 s as shown in Section \ref{overlay_results}.

\subsection{Conclusion}

In this section, it was shown that safe storage only has marginally higher reliability, when compared to fast storage, but that it is much slower when compared to fast storage. It was also shown that parallel retrieval leads to higher reliability and responsiveness at a cost of higher required bandwidth. The higher required bandwidth is still less than that required by the medium or high overlay storage configurations.

Group storage was found to be efficient in terms of higher layer data. Since storage and retrieval are separate data streams, PithosTestApp transfers a total of 161 Bps to and from Pithos. In response to those two data streams, group storage generates approximately 183 Bps traffic. This means that 88\% of data in group storage is received from or destined to PithosTestApp, with 12\% overhead. Overlay storage on the other hand generates approximately 86\% overhead. A reduction in overlay storage overhead will, therefore, significantly decrease the amount of overall Pithos overhead.

To place bandwidth values into perspective, the total required bandwidth for Pithos when using parallel group storage and medium overlay storage, still only requires 15.4 kilo bits per second (kbps) inbound and 15 kbps outbound. This is well within the limits of most modern Internet connections that are capable of providing 1 to 40 Mbps bandwidth.

\section{Responsiveness distributions}

To evaluate responsiveness, it is not sufficient to only evaluate mean responsiveness, since the standard deviation also plays a role. The time it takes for the authoritative storage to retrieve an object will influence the latency users experience when interacting with the virtual environment (VE). Real-time VE interactions are sensitive to both latency and jitter. It is thus important to also review the range that latencies might have.

To calculate the responsiveness, the Oversim SimpleUnderlayNetwork was used for the physical network for all experiment but one.

The percentiles shown on all distributions indicate the percentage of requests serviced with a latency less than the individual time.

This sections presents all responsiveness distributions in the Pithos simulation. With the exception of the LAN experiment, the experimental setup is as in Section \ref{simulation_setup}:
%
\begin{itemize}
\item Network of 2500 peers and 100 super peers.
\item Simulation length of 10,000s.
\item Exponential object lifetime with 1800s mean and 300s TTL.
\item Object sizes of 1024 bytes.
\item Generating a store and retrieve request once every 5s.
\item Using Chord as overlay.
\item Storing six object replicas.
\item All requests are for local group objects.
\end{itemize}

\subsection{Overlay storage and retrieval}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=10mm 30mm 270mm 170mm, width=\columnwidth]{overlay_put_sf}
 \caption{Overlay storage responsiveness}
 \label{fig_overlay_put_sf}
\end{figure}
%
Figure \ref{fig_overlay_put_sf} shows that to store an object in the overlay can take anywhere from 0.1 to 4 seconds, but 80\% of storage requests are less than 1.569s.

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 30mm 270mm 175mm, width=\columnwidth]{overlay_get_sf}
 \caption{Overlay retrieval responsiveness}
 \label{fig_overlay_get_sf}
\end{figure}
%
Figure \ref{fig_overlay_get_sf} shows that to retrieve an object from the overlay can take anywhere from 0.1 to 6 seconds, but 80\% of requests are less than 2.322s. Figure \ref{fig_overlay_get_sf} also shows a spike at 3 seconds, when overlay retrieval is performed. 0.55\% of requests take 3 seconds to complete. When evaluating the CDF, it was found that a spike exists every 1.5s, with the magnitude of the spike decreasing for longer times.

The spikes are thought to be an artifact of the third-party DHT implementation, since this spike was found when simulating both Pastry and Chord so cannot be an artifact of any specific routing overlay. It was also found when simulating for the coordinate-based underlay as well as a fixed delay underlay, so it cannot be an artifact of the type of underlay used. Because of the low percentage of requests that exhibit this behaviour, a rigorous study into this phenomenon was not performed.

\subsection{Group storage}
\label{group_storage_eval}

\subsubsection{Fast storage}
\label{group_put_f_fp}

Figure \ref{fig_group_put_ff} shows the distribution of group storage for fast storage.

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=5mm 45mm 265mm 210mm, width=\columnwidth]{group_put_ff}
 \caption{Group storage responsiveness for fast storage}
 \label{fig_group_put_ff}
\end{figure}
%
Figure \ref{fig_group_put_ff} shows a spike at zero seconds, with 1.82\% of group storage requests having zero network latency. These are group requests that were made when no objects were available in a group and the request immediately returned a failure response. Apart from the spike, Figure \ref{fig_group_put_ff} also shows that the responsiveness is distributed over a small range: with 86\% of requests taking less than 0.1s.

\subsubsection{Safe storage}
\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=5mm 30mm 270mm 170mm, width=\columnwidth]{group_put_sf}
 \caption{Group storage responsiveness for safe storage}
 \label{fig_group_put_sf}
\end{figure}
%
Figure \ref{fig_group_put_sf} shows the responsiveness distribution for safe storage. Because safe storage is slower than fast storage, the mean response time is longer. The maximum and minimum responsiveness values are also greater than for fast storage: from zero to 0.8 seconds, with 35\% of requests taking less than 0.1s. This is still smaller than the range of overlay storage values.

Figure \ref{fig_group_put_sf} also contains a spike at 10s. 0.68\% of requests take 10s, which is due to the storage timeout being set to 10s. What should be noted is that these responsiveness graphs show both success and failure responsiveness. In other words, it shows how quickly a response is received, even if that response is a failure. The responses received from 10s are all failure responses, where no response was received from the destination node and an internal timeout occurred.

\subsection{Group retrieval}
\label{group_retrieve_eval}

\subsubsection{Fast retrieval}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 35mm 265mm 175mm, width=\columnwidth]{group_get_zoom_sf}
 \caption{Enlarged view of the group retrieval responsiveness for fast retrieval}
 \label{fig_group_get_zoom_sf}
\end{figure}
%
Figure \ref{fig_group_get_zoom_sf} shows group retrieval responsiveness for fast retrieval, without showing the full extent of the zero time responses. This type of retrieval has 24\% of requests with zero second latency. These requests are the requests where the node generating the object is chosen to store the object. If the required number of replicas is high, compared to the group size, there is a high likelihood that the node originating the request will be chosen as a host node to the object.

It should be noted that the node that originally stored the object does not have local access to the object. Only other nodes that did not originally store the object may have access to local copies. This is the reason why such a significant spike is not present in fast storage.

Figure \ref{fig_group_get_zoom_sf} also shows multiple peaks, which is shown to be an artifact of the underlying physical layer in Section \ref{lan_retrieval}.

For fast group retrieval 90\% of requests are serviced within 0.318s, compared to overlay retrieval where only 0.08\% of requests are serviced within 0.318s.

\subsubsection{Parallel retrieval}
\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 35mm 265mm 175mm, width=\columnwidth]{group_get_fp}
 \caption{Group retrieval responsiveness for parallel retrieval}
 \label{fig_group_get_fp}
\end{figure}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 35mm 265mm 175mm, width=\columnwidth]{group_get_zoom_fp}
 \caption{Enlarged view of the group retrieval responsiveness for parallel retrieval}
 \label{fig_group_get_zoom_fp}
\end{figure}
%
Figure \ref{fig_group_get_fp} shows group retrieval responsiveness for parallel retrieval. Figure \ref{fig_group_get_zoom_fp} shows the enlarged view. 95\% of parallel retrieval requests are serviced below 0.194s, whereas only 74\% of fast retrieval requests are serviced below 0.194s. The higher responsiveness of parallel retrieval is as a result of multiple replicas queried and the fastest response being used (as previously explained in Section \ref{pithos_resp_rel_results}).

The shape of Figure \ref{fig_group_get_zoom_fp} differs from that of Figure \ref{fig_group_get_zoom_sf} due to the difference between selecting a single random node ($1/r$) in the group for retrieval, to selecting the fastest of $r$ nodes in the group for retrieval, where $r$ is the number of object replicas currently in the group.

\subsection{LAN performance}
\label{lan_retrieval}

It is expected that the characteristics of the underlying network architecture influence the performance of any higher layer architecture build on top of it. To investigate the influence of the underlay, an experiment is performed where the coordinate-based underlay network is replaced by a fixed delay 1ms underlay with 0.1\% jitter.

It is expected that group storage should show two hop responsiveness, because of the fully connected group network topology, and that overlay storage should show more hops than group storage, because of the $O(\log(N))$ performance of the overlay.

\subsubsection{Group retrieval}

Testing the LAN performance of group retrieval allows for the investigation of the multimodal behaviour (local maxima) seen in Figures \ref{fig_group_put_sf} and \ref{fig_group_get_zoom_sf}, which were suspected to be caused by the underlying network. The multimodal behaviour is a function of the distance of peers in the physical network layer.

It should also be verified that the responsiveness of Pithos will improve if the physical layer latencies are reduced.

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 30mm 265mm 180mm, width=\columnwidth]{group_get_lan}
 \caption{Group retrieval responsiveness for fast storage and fast retrieval, running on a 1ms underlay network.}
 \label{fig_group_get_lan}
\end{figure}
%
Figure \ref{fig_group_get_lan} shows group retrieval performance for fast storage and fast retrieval, running on a 1ms underlay network. This figure shows the same operation shown in Figure \ref{fig_group_get_zoom_sf}, but for the underlay being a fixed 1ms underlay, instead of a coordinate-based underlay.

Two main spikes are seen in the figure, one at 0s and another at 2ms. The second spike is surrounded by the 0.1\% jitter, but the first spike contains no jitter, since no network message is sent out for the local storage. There are no other measured times. 24\% of requests are served with zero network latency.

This is what is expected from group storage, since every request in group storage is either zero hops or two hops. For two hops, one hop is required to send the request, and another to receive the response, which gives $2\times 1 ms = 2 ms$. The zero hops case is due to local objects being retrieved, as explained in Section \ref{group_put_f_fp}.

No additional peaks are perceived, as opposed to the peaks seen earlier. The mean group storage performance has improved to 1.6ms, from the 192ms for the coordinate-based underlay network.

\subsubsection{Overlay retrieval}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 30mm 270mm 175mm, width=\columnwidth]{overlay_get_lan_wide}
 \caption{Overlay retrieval responsiveness for fast storage and fast retrieval, running on a 1ms underlay network and showing the compete x-axis.}
 \label{fig_overlay_get_lan_wide}
\end{figure}
%
Figure \ref{fig_overlay_get_lan_wide} shows the responsiveness of overlay storage for the LAN underlay network. Three groups of latencies can be observed. One close to zero seconds, one at 1.5s and another at 3s. The first group contains the majority (96\%) of overlay requests, the second 1\% and the third, 3\% of overlay requests. It is not clear why there are three distinct responsiveness groups. Because these features are only responsible for 4\% of the requests, they were not deemed to require an in-depth investigation.

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=10mm 30mm 275mm 175mm, width=\columnwidth]{overlay_get_lan}
 \caption{Overlay retrieval responsiveness for fast storage and fast retrieval, running on a 1ms underlay network.}
 \label{fig_overlay_get_lan}
\end{figure}
%
Figure \ref{fig_overlay_get_lan} shows the group close to zero seconds. This group, as well as the other two, exists out of multiple hops. These hops are, however, not underlay hops, but overlay hops, since they are more than 1ms apart. The overlay creates its own application layer network and the overlay storage takes $O(\log(N))$ overlay hops. A single overlay hop may contain multiple underlay hops, which is what the multiple hops represent in Figure \ref{fig_overlay_get_lan}.

The mean overlay retrieval for LAN responsiveness is 130ms, which is significantly slower than the 1.6ms of group retrieval for LAN responsiveness.

\subsection{Overall storage}

\subsubsection{Fast storage}
After having presented the separate responsiveness profiles for overlay and group storage, the overall Pithos responsiveness is presented here which is a combination of the responsiveness profiles of the underlying group and overlay responsiveness.

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=5mm 50mm 265mm 205mm, width=\columnwidth]{overall_put_ff}
 \caption{Overall storage responsiveness for fast storage}
 \label{fig_overall_put_ff}
\end{figure}
%
Figure \ref{fig_overall_put_ff} shows the overall storage responsiveness for fast storage. The shape is similar to that of Figure \ref{fig_group_get_zoom_fp}, a seemingly exponential distribution. The shape is derived from how fast storage tracks a success: the first successful storage response from group storage is sent to the higher layer, effectively taking all responses and choosing the fastest one. Fast storage responsiveness is, therefore, exactly the same mechanism as with parallel retrieval, which is why the distributions look that same.

95\% of fast storage requests are serviced within 0.185s.

\subsubsection{Safe storage}
\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=5mm 35mm 270mm 170mm, width=\columnwidth]{overall_put_sf}
 \caption{Overall storage responsiveness for safe storage}
 \label{fig_overall_put_sf}
\end{figure}
%
Figure \ref{fig_overall_put_sf} shows the overall storage responsiveness for safe storage. Because a response is only sent when sufficiently many group responses have been received \emph{and} when the overlay response has been received, the shape of the distribution is identical to that of the overlay storage distribution, shown in Figure \ref{fig_overlay_put_sf}.

The reason why the shape has no correspondence to group storage responsiveness is because, as previously shown, overlay storage is almost always slower than group storage. Because safe storage always waits for the reply from the overlay storage module, its responsiveness is dominated by the responsiveness of overlay storage.

95\% of safe storage requests are serviced within 3.373s. Compared to fast storage, only 0.0174\% of safe storage requests are serviced within 0.185s.

\subsection{Overall retrieval}
\subsubsection{Fast retrieval}
\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 30mm 265mm 180mm, width=\columnwidth]{overall_get_ff}
 \caption{Overall retrieval responsiveness for fast retrieval}
 \label{fig_overall_get_ff}
\end{figure}
%
Figure \ref{fig_overall_get_ff} shows overall retrieval responsiveness for fast retrieval. The shape is similar to that of fast group retrieval in Figure \ref{fig_group_get_zoom_sf}, because in this case, fast retrieval returns the first result received. Since fast group retrieval is mostly faster then overlay retrieval, the overall retrieval distribution will closely match that of fast group retrieval.

\subsubsection{Parallel retrieval}
\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 30mm 265mm 180mm, width=\columnwidth]{overall_get_fp}
 \caption{Overall retrieval responsiveness for parallel retrieval}
 \label{fig_overall_get_fp}
\end{figure}
%
Figure \ref{fig_overall_get_fp} shows the overall retrieval responsiveness for parallel retrieval. Overall parallel retrieval mirrors parallel group retrieval, since parallel retrieval is faster than overlay retrieval.

\subsection{Conclusion}

In this section some responsiveness distributions were shown. The first reason is that a fair comparison does not only consider the mean, but compares the distributions. These include the distributions for overlay storage and retrieval, fast and safe group storage, fast and parallel group retrieval, LAN performance, fast and safe overall storage, and fast and parallel overall retrieval. Secondly, it enables the highlighting of various structures and characteristics of storage and retrieval as they relate to certain quantities or mechanisms in Pithos. Thirdly, the distributions verify that Pithos meets the responsiveness and reliability design requirements.

When comparing the overall Pithos performance to the underlying group and overlay performance, it shows that Pithos is indeed a hybrid of those two storage types, but also that it is selecting the best qualities of both. This means that Pithos should perform better than the overlay chosen for use in Pithos.

\section{Reliability, responsiveness and bandwidth for various group probabilities}
\label{group_probability_results}

The design of Pithos makes use of user groups and distance-based storage on a group layer, as stated in Sections \ref{grouping_design} and \ref{distance_based_design}. To verify the actual reliability and responsiveness of Pithos, it is necessary to investigate Pithos's performance for various group probabilities. In the final P2P MMVE architecture it is assumed that the percentage of in-group requests will be much higher than that of out-of-group requests, since distance-based storage is used. This assumption is based on the fact that with group-based distance-based storage, the objects that are frequently of interest to the user will be stored in that user's group.

\subsection{Experimental setup}

Because the exact probability that an object request will be for a group object is not yet known, a sweep is done for various group probabilities (the probability that a request is for a in-group object) to investigate the effect of group probability on Pithos's performance.

Because we expect that as the group probability changes, we will have a linear combination of group performance and overlay performance, the low overlay configuration is selected to better visualise this relationship.

The simplest storage and retrieval methods: fast storage and fast retrieval are selected. The specific type of group storage retrieval method is not important for this experiment, since the purpose of the experiment is to show the interplay between group and overlay storage.

As with the previous experiments, the following configuration parameters are chosen for reasons already discussed:
%
\begin{itemize}
\item Network of 2500 peers and 100 super peers.
\item Simulation length of 10,000s.
\item Using the Oversim SimpleUnderlayNetwork for the physical network.
\item Exponential object lifetime with 1800s mean and 300s TTL.
\item Object sizes of 1024 bytes.
\item Generating a store and retrieve request once every 5s.
\item Using Chord as overlay.
\item No object repair is performed.
\item Storing six object replicas.
\end{itemize}

\subsection{Reliability}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 30mm 270mm 180mm, width=\columnwidth]{group_prob_rel}
 \caption{Reliability of Pithos, group storage and overlay storage for various group probabilities.}
 \label{fig_group_prob_rel}
\end{figure}
%
Figure \ref{fig_group_prob_rel} shows the effect group probability has on Pithos's overall reliability, compared with the underlying group storage and overlay storage reliabilities. The figure shows that the most reliable storage mechanism is group storage. It shows that group and overlay reliability are independent of the group percentage, which is as expected since the group storage and overlay storage modules are independent. Each request that is received from the higher layer (PithosTestApp) is relayed to both the DHT storage and group storage modules by the peer logic module.

When an object request is sent to group storage for an object that is not stored in that group, the group storage module reports that there does not exist such an object in the group and the request is not handled. The only possible reply is then from the overly storage module. Figure \ref{fig_group_prob_rel} shows that the overall Pithos reliability is a linear combination of group storage and overlay storage, weighted by the group probability.

These results can be verified theoretically by seeing that the reliability of Pithos is the union of the reliability of both group and overlay storage and is given by
%
\begin{align}
     \Gamma_{\textrm{Pithos}}& = \Gamma_{\textrm{group}} \cup \Gamma_{\textrm{overlay}} \\
     \textrm{which }
  E[\Gamma_{\textrm{Pithos}}]& = E[\Gamma_{\textrm{group}} \cup \Gamma_{\textrm{overlay}}] \notag \\
                             & = E[\Gamma_{\textrm{group}}] + E[\Gamma_{\textrm{overlay}}] \notag \\
                             & = P(\textrm{group})\Gamma_{\textrm{group}} + (1-P(\textrm{group}))\Gamma_{\textrm{overlay}}
\end{align}
%
where $\Gamma_{\textrm{Pithos}}$ is the overall Pithos reliability, $\Gamma_{\textrm{group}}$ is the group reliability, $\Gamma_{\textrm{overlay}}$ is the overlay reliability, and $P_{\textrm{group}}$ is the group probability.

This result shows that the reliability of Pithos varies linearly between overlay and group storage reliability as the group probability is varied. It should be noted that if a more reliable overlay was used, the medium or high configurations for example, the difference between group and overlay reliability is less. The low overlay configuration was just selected to better illustrate the linear relationship.

\subsection{Responsiveness}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 30mm 275mm 170mm, width=\columnwidth]{group_prob_resp}
 \caption{Responsiveness of Pithos, group storage and overlay storage for various group probabilities.}
 \label{fig_group_prob_resp}
\end{figure}
%
Figure \ref{fig_group_prob_resp} shows the responsiveness of Pithos compared with the underlying responsiveness of group and overlay storage. Take note that a lower value is preferred in this graph and that low latency is high responsiveness. As with the reliability, overall responsiveness is also shown to be a linear combination of group and overlay responsiveness.

An apparent anomaly is the group storage latency that increases with an increase in group probability. Recall that if a request is sent to group storage for an object not in the group, group storage immediately returns failure. The failure response is recorded as a response from group storage, even if this response is a failure.

The lower the group probability, the more failure responses are returned by group storage, which are returned instantly. It is these responses that decrease the mean group storage latency for lower group probabilities. When failure responses are ignored, group latency remains constant at the value of 100\% group probability.

\subsection{Bandwidth}
\label{group_probability_bandwidth}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=15mm 35mm 270mm 170mm, width=\columnwidth]{group_prob_bw}
 \caption{Bandwidth usage of Pithos, group storage and overlay storage for various group probabilities, as well as the bandwidth sent to, and received from Pithos.}
 \label{fig_group_prob_bw}
\end{figure}
%
Figure \ref{fig_group_prob_bw} shows the bandwidth requirements of Pithos in bytes per second (Bps). Pithos, group and overlay bandwidths show the mean of the inbound and outbound bandwidth. Figure \ref{fig_group_prob_bw} also shows the underlying bandwidth requirements of group storage and overlay storage. To determine the actual overhead that Pithos requires, the graph also shows the amount of data that is sent to, and received from, Pithos, from and to the higher layer (PithosTestApp).

Figure \ref{fig_group_prob_bw} shows that overlay storage bandwidth remains constant, but that group storage bandwidth increases. Overlay storage remains constant, because no matter what the group probability is, the overlay storage is always queried for a data item and a data item is returned with the same probability (based on the reliability). Group storage, on the other hand, only returns data if the object exists within the group. Higher group probability means that more objects are requested from within the group, which means that group probability will return more objects and thereby use more data.

As shown, the overall Pithos bandwidth the the sum of the bandwidth required by group and overlay storage. The Pithos overhead is approximately 76\% of Pithos's UDP data, where, depending on the group probability, 85\% to 62\% of overhead is contributed by overlay storage for the low overlay configuration.

\subsection{Conclusion}

This section reviews the performance of Pithos for various group probabilities and also shows the interaction between overlay and group storage in terms of reliability, responsiveness and bandwidth.

All the experiments verified that for a low group probability, the characteristics of overlay storage are dominant and for high group probability, the characteristics of group storage are dominant. As previously stated, because of the distance-based storage design, high group probabilities are expected.

What was shown in this section is that overlay storage provides lower reliability than group storage with higher bandwidth requirements. This underpins the need for an overlay better suited to environments with network churn and improved lookup reliability. Before overlay efficiency can be improved, it is therefore important to create a grouping algorithm that has the highest possible group probability.

\section{Reliability, responsiveness and bandwidth for various peer lifetimes}
\label{repair_results}

Object replicas inserted into Pithos will all eventually disappear due to network churn. The rate at which replicas are removed from the network can be reduced by employing object repair. This enables Pithos to trade storage space for network bandwidth, by using fewer replicas with a higher repair rate. Network bandwidth can also be saved by having more replicas and a lower repair rate.

The effect of node replicas on the reliability, responsiveness and bandwidth usage of Pithos will be explored in this section. Reliability is tightly coupled to the lifetime of peers, since peers that live longer will store objects longer, meaning objects stored on peers with longer expected object lifetimes will have longer expected lifetimes themselves. The main reason for being unable to retrieve an object from Pithos is because a peer has left the network. It is, therefore, expected that if peers life longer the system reliability increases.

\subsection{Experimental setup}

It is expected object repair will increase objects lifetimes, thereby increasing reliability, but also increasing bandwidth usage. It is also expected that object lifetimes are directly related to peer lifetimes. To show this, node lifetimes in the experimental setup were varied from 100s to 1800s. Time steps were selected closer together, for period where reliability, responsiveness and bandwidth values changed faster.

Three types of retrieval methods are compared: fast retrieval, parallel retrieval and fast retrieval with object repair. Two types of repair are compared: periodic and leaving repair. Periodic repair is set to have repair periods of 100s.

As was stated earlier, the object TTL will also influence the reliability, since if objects have to be maintained for longer periods of time there exists a greater probability of all object replicas being lost. To better show the effect of repair on object reliability, object TTLs were increased to 1000s from 300s.

To show the sensitivity of reliability to node lifetime, two node lifetime distributions are explored in this experiment: the exponential and Pareto lifetime distributions. The Pareto distribution is a heavy-tailed distribution, which means that a certain percentage of nodes will live a significantly longer time than others. It is expected that the Pareto distribution will lead to higher reliability, since there is a higher probability of one of the object replicas being stored on a node with a long lifetime.

The rest of the experimental setup is as follows:
%
\begin{itemize}
\item Fast group storage is used.
\item Network of 2500 peers and 100 super peers.
\item Simulation length of 10,000s.
\item Using the Oversim SimpleUnderlayNetwork for the physical network.
\item Object sizes of 1024 bytes.
\item Generating a store and retrieve request once every 5s.
\item Using Chord as overlay.
\item Storing six object replicas.
\item All requests are for local group objects.
\end{itemize}

\subsection{Reliability}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=15mm 30mm 275mm 170mm, width=\columnwidth]{repair_rel}
 \caption{Reliability of Pithos for various mean node lifetimes, comparing no repair, no repair with parallel retrieval, no repair using Pareto node lifetimes, leaving repair and periodic repair with 100s periods.}
 \label{fig_repair_rel}
\end{figure}
%
Figure \ref{fig_repair_rel} shows request reliability for various node lifetimes for no repair, no repair using parallel retrieve, leaving repair and periodic repair.

As expected, doing no repair does not cope well with short node lifetimes compared to an object TTL of 1000s. The object TTL is important when evaluating performance, since a network that requires objects to be stored for longer has to maintain the object replicas for a longer amount of time. When the expected node lifetime is comparable to the object TTL, the reliability of the system when not using repair is similar to the system reliability when repair is used. In other words, when peer lifetimes are of the same order of magnitude as object TTL, repair is not necessary.

This observation is helpful when designing a P2P MMVE. Objects might be classified according to how long they should remain in the system. Objects that should only remain in the system for approximately the same amount of time as the expected user session time need not use repair mechanisms, if a sufficient number of replicas are used.

When node lifetimes are the same as the periodic repair interval, leaving repair copes better than periodic repair. The periodic repair mechanism might be adjusted to less than the minimum expected node lifetime in the system, but this will increase the load on the super peer, which has to perform the periodic checks. From the data it seems that leaving repair might be able to better handle a situation where node lifetimes have a high dynamic range, since the rate at which peers leave the network is directly tied to how often leaving repair performs repairs.

Except for the case where the periodic repair timer is equal to the expected node lifetime, leaving and periodic repair appear to perform similarly in terms of reliability.

Parallel retrieval, employing no repair mechanism, is most reliable and consistently reliable for all node lifetimes. The second most reliable setup is no repair with Pareto lifetime distributions. It should be noted that a Pareto node lifetime distribution leads to more reliable system in every instance. In other words, when comparing the cases of no repair with repair, Pareto lifetime distributions with repair also performs better than the no repair case for the same lifetime distributions.

\subsection{Responsiveness}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=10mm 30mm 275mm 175mm, width=\columnwidth]{repair_resp}
 \caption{Latency of Pithos and the higher layer requests for various mean node lifetimes for the the case with no repair, no repair using parallel retrieval, no repair using Pareto node lifetimes, leaving repair and periodic repair.}
 \label{fig_repair_resp}
\end{figure}
%
Figure \ref{fig_repair_resp} shows the latencies for various mean node lifetimes. The time that it takes to service a request is highly coupled to the reliability of the system. More requests will fail for a less reliable system. The only way for the peer making the request to know that a request has failed is for that request to timeout. The more requests that fail, the more the latency migrates to the timeout latency of 10s. This shows the importance of choosing a timeout as short as possible, that is still able to handle all requests.

\subsection{Bandwidth}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=10mm 30mm 275mm 175mm, width=\columnwidth]{repair_bw}
 \caption{Bandwidth usage of Pithos and the higher layer for various mean node lifetimes for the the case with no repair, no repair using parallel retrieval, no repair using Pareto node lifetimes, leaving repair and periodic repair.}
 \label{fig_repair_bw}
\end{figure}
%
Figure \ref{fig_repair_bw} compares the bandwidth usage of the various repair techniques. It should be noted that the largest part of Pithos's bandwidth usage is contributed by overlay storage, as shown in Sections \ref{overlay_results} and \ref{group_probability_bandwidth}.

Although parallel retrieval has been shown to be the most reliable retrieval mechanisms for various node lifetimes, Figure \ref{fig_repair_bw} shows that it required the most bandwidth, with only between 1.5\% to 8\% usable data transferred depending on node lifetime. Parallel retrieval also converges to a higher required bandwidth of approximately 2000Bps, compared to other methods that converge to approximately 1400Bps for high node lifetimes.

The reason why parallel retrieval's bandwidth continues to grow is due to the mean number of object replicas available. Although parallel retrieval always attempts to retrieve six replicas (for this experiment), depending on the network conditions, the average number of object replicas is always smaller than the required number of object replicas. This is especially true for the case with no repair, where an object starts with the maximum number of replicas, but that number gradually decreases over the lifetime of the object. Object lifetime, which determines the average number of available replicas, is highly dependant on node lifetime, as will be discussed in Chapter \ref{chp:MODELLING}.

This means that the longer the average node lifetime, the higher the average number of replicas per object. The bandwidth usage shown for parallel retrieval thus converges to an amount representing six replicas in the system. The bandwidth does, however, not increase six fold, since most of the bandwidth is due to overlay storage, which does not increase.

The bandwidth usage of leaving and periodic repair are similar for long peer lifetimes, compared to the periodic repair timer. Bandwidth usage is low for short node lifetimes, because of the low reliability. Many retrieve requests fail for short node lifetimes, which means that fewer object are returned and less bandwidth is used.

Although doing no repair is less reliable, it used less bandwidth, because no object repairs have to be performed. Pareto lifetimes distributions also require less bandwidth, since the overlay does not have to exchange as much routing information.

\subsection{Conclusion}

The leaving and periodic repair mechanisms were found to possess similar reliability and bandwidth performances. It seemed that leaving repair does, however, cope better with dynamic node lifetimes. A periodic timer also has to be designed for specific network parameters, including expected node lifetime and object TTL. If, during the lifetime of the network, the parameters change, the system will not be able to dynamically adapt.

As expected, doing no repair is less reliable than doing repair, but uses less bandwidth. Parallel retrieval is highly reliable, but requires a large amount of bandwidth.

Pithos shows improved performance when using Pareto lifetime distributions, discussed in Section \ref{exp_vs_pareto}, compared to exponential node lifetime distributions. Since Pareto distributions have been found to better match node lifetimes in virtual worlds, this improvement is significant. Exponential distributions were used in this section precisely because they are a more rigorous test of Pithos, compared to Pareto distributions.

\section{Security}
\label{malicious_results}

The results thus far have shown that Pithos is both responsive and reliable. In this section, in order to verify that Pithos meets the security design requirements specified, we investigate the object retrieval reliability in the presence of malicious users in the P2P network.

As a result of its design, fast retrieval is not resistant to malicious users, since it will retrieve corrupted objects, if the first retrieval response was received from a malicious user. Safe retrieval uses a quorum mechanism to respond with the object, which the majority of queried peers agree is correct. We therefore expect safe retrieval to be resistant to the presence of malicious users.

We also wish to investigate the reliability of the security mechanism as a function of the number of queried peers. We expect the reliability to increase with a larger quorum, but at the expense of a slower response time and an increase in bandwidth.

\subsection{Experimental setup}

Each object in Pithos has a value attribute that is set to a random floating point value when an object is created for the simulation. The value of the object is stored in PithosTestApps's global object list. It should be noted that for simulation purposes, an object's size is not related to its content. An object's size is set using a random distribution and this is the value used to compute transmission bandwidth and latency.

Whenever a malicious node receives a retrieval request it replies with a modified version of the requested object. The object is modified by modifying the object value. An object is assigned a uniformly random value by a malicious node. Because of the way objects are altered, we implicitly assume that there exists no collusion in the network. When PithosTestApp receives a requested object, it checks that object against the global object list to determine whether the correct object was received. PithosTestApp then records Pithos's reliability.

Pithos selects the object that is the same in a majority of responses and sends it to the higher layer. If no object has a majority, a failure response is sent to the higher layer.

The percentage of users that are malicious is varied from 0\% to 100\% in steps of 12.5\%. A comparison of safe retrieval is performed by first retrieving four of the six stored replicas and then increasing the number of retrievals to six.

As with the previous experiments, the following configuration parameters are chosen for reasons already discussed:
%
\begin{itemize}
\item Fast group storage is used.
\item Network of 2500 peers and 100 super peers.
\item Simulation length of 10,000s.
\item Using the Oversim SimpleUnderlayNetwork for the physical network.
\item Exponential object lifetime with 1800s mean and 300s TTL.
\item Object sizes of 1024 bytes.
\item Generating a store and retrieve request once every 5s.
\item Using Chord as overlay.
\item Storing six object replicas.
\item No object repair is performed.
\item All requests are for local group objects.
\end{itemize}

\subsection{Reliability}
\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 30mm 270mm 175mm, width=\columnwidth]{malicious_nodes_rel}
 \caption{Reliability of various Pithos retrieval schemes for varying factors of malicious node probability.}
 \label{fig_malicious_nodes_rel}
\end{figure}
%
Figure \ref{fig_malicious_nodes_rel} shows Pithos's reliability as a function of the percentage of malicious users in the network for both the fast retrieval and safe retrieval schemes. As expected, the fast retrieval reliability is almost the same as the malicious user percentage. System reliability for fast retrieval is the product of the malicious user factor and the system reliability when malicious users are present in the network.

The reason for this direct relationship is because the probability of an object retrieval being corrupted in the network is equal to the probability of a peer being malicious, since a malicious peer corrupts all objects returned and a non-malicious peer corrupts none of the objects returned. The overall probability is then the probability that an object retrieval would have succeeded if no malicious nodes were present, multiplied by the probability of nodes being malicious.

Overlay retrieval, using no form of security as with fast retrieval, performs worse than fast retrieval. This is especially true for higher malicious node probabilities.

Figure \ref{fig_malicious_nodes_rel} also shows the improvement received from using safe retrieval. The curve shows that safe retrieval provides greater benefit for smaller factors of malicious nodes. As soon as the majority of objects are corrupted, which occurs when the malicious users probability is greater than 50\%, object reliability drops significantly.

The figure also shows improved reliability, when more received objects are compared to select a majority. Retrieving more objects for comparison will, however, increase bandwidth requirements. Bandwidth increases in line with that shown in Section \ref{bandwidth_requirements}, because safe retrieval is parallel retrieval, but for an additional compare operation. It should be noted that more retrievals than compares may be performed to increase responsiveness at the cost of additional bandwidth.

An interesting situation arises, where safe retrieval reliability drops below fast retrieval reliability. When a majority can no longer be identified by safe retrieval, a failure response is sent up. This is as opposed to fast retrieval that sends any object received. It is possible the the object that was selected by fast storage was not maliciously altered, but also not in the majority. In this scenario, fast retrieval will sometimes send objects to the higher layer that are correct, where safe storage just responds with failure, because it cannot achieve a majority decision.

Figure \ref{fig_malicious_nodes_rel} also shows the performance of overlay storage under the presence of malicious nodes if no security mechanisms are implemented in overlay storage. The performance degrades as the percentage of malicious users increase. The performance is also worse than the overall Pithos performance.  It should be noted that the overall Pithos performance is not influenced by Overlay storage in this graph, since 100\% group probability is used. For lower percentages of group probability, the linear relationship between group and overlay storage, explored in Section \ref{group_probability_results} exists.

\subsection{Responsiveness}
\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=20mm 30mm 270mm 175mm, width=\columnwidth]{malicious_nodes_resp}
 \caption{Responsiveness of various Pithos retrieval schemes for varying malicious node probabilities.}
 \label{fig_malicious_nodes_resp}
\end{figure}
%
Figure \ref{fig_malicious_nodes_resp} shows the responsiveness of Pithos for various malicious node probabilities. Fast retrieval has the lowest latency, since it responds with the first object received and does not wait to compare objects. Overlay retrieval is slower than all other forms of retrieval, because of the nature of overlay retrieval as previously discussed.

Safe retrieval, when comparing four objects is slower than fast retrieval, since it has to wait for four objects before it can compare. The responsiveness of the four compare retrieval is thus the responsiveness of the slowest of four requests. Safe retrieval, comparing six objects is slower than comparing four objects, since the responsiveness is now the slowest time of six requested objects. When requesting more objects, there is a higher probability that a slower object will be selected.

\subsection{Bandwidth}
\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=10mm 30mm 270mm 175mm, width=\columnwidth]{malicious_nodes_bw}
 \caption{Bandwidth usage of various Pithos retrieval schemes for varying factors of malicious node probability.}
 \label{fig_malicious_nodes_bw}
\end{figure}
%
Figure \ref{fig_malicious_nodes_bw} shows the bandwidth usage of various retrieval schemes for various malicious node probabilities. Overlay retrieval uses the least amount of bandwidth, since Pithos also contains an overlay storage section, which means Pithos cannot use less bandwidth than overlay retrieval. Fast retrieval uses more bandwidth than overlay retrieval and the difference between overlay retrieval and fast retrieval is the amount of bandwidth required by the group storage module.

Safe retrieval performing four comparisons and safe retrieval performing six comparisons use the same amount of bandwidth, since both retrieval methods request six objects. The one method only uses the first four responses, while the other uses all six responses. Safe retrieval uses more bandwidth than fast retrieval, since six objects are requested in group storage, instead of the one object requested in fast retrieval.

\subsection{Conclusion}

The section shows that Pithos's safe retrieval mechanism can be used to increase reliability in the presence of malicious users in the network, at the cost of responsiveness and bandwidth. Since we cannot assume that there will not be malicious nodes in a virtual environment, this cost is deemed acceptable.

During the lifetime of the virtual world, it is important to monitor the malicious user percentage, to determine how parameters, such as number of retrieve requests and number of compares, should be adjusted to combat the threat while minimising bandwidth and maximising responsiveness.

In practice, a low malicious node factor is expected, since it is assumed that malicious users are in the minority. If the virtual world has a majority of malicious users, it will most likely not be sustainable.

\section{Fairness}

It has been shown that Pithos meets at least three of the five design requirements. In this section, it is verified that Pithos also meets the design requirement of fairness. Fairness requires that no peers should contribute none of their storage space and that no peers should have to contribute a significantly larger proportion of their storage space than other peers. We also compare Pithos to overlay storage and show it to be almost as fair as overlay storage.

\subsection{Experimental setup}

To measure object fairness, the length of time that nodes generate objects for were increased from 20s to 100s, to allow more objects to enter the storage system. The mean rate of object generation was kept constant at 1 object every 5s.

Object fairness is measured as the average number of objects that were stored on a node during its lifetime. Each node records its local object store size at regular intervals during its lifetime. At the end of a node's lifetime, it calculates the average number of objects that were stored on it. The results shown are, therefore, the average number of objects stored per node over that node's lifetime and the distribution is recorded over all nodes that were removed from the network during the simulation.

As with the previous experiments, the following configuration parameters are chosen for reasons already discussed:
%
\begin{itemize}
\item Fast group storage is used.
\item Fast group retrieval is used.
\item Network of 2500 peers and 100 super peers.
\item Simulation length of 10,000s.
\item Using the Oversim SimpleUnderlayNetwork for the physical network.
\item Exponential object lifetime with 1800s mean and 300s TTL.
\item Object sizes of 1024 bytes.
\item Generating a store and retrieve request once every 5s.
\item Using Chord as overlay.
\item Storing six object replicas.
\item No object repair is performed.
\item All requests are for local group objects.
\end{itemize}

\subsection{Overlay fairness}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=15mm 30mm 270mm 175mm, width=\columnwidth]{fairness_overlay}
 \caption{The distribution of objects over peers for overly storage, when measuring the average number of objects stored during a peer's lifetime.}
 \label{fig_overlay_fairness}
\end{figure}
%
Figure \ref{fig_overlay_fairness} shows the distribution of overlay objects over nodes in the network. The distribution has a mean and standard deviation of 15.7 and 6.4 objects per node respectively. The figure also lists the 10\%, 25\%, 50\%, 75\% and 90\% percentiles for overlay storage.

1\% of peers do not store any objects, which although not ideal, is a small percentage of the total number of peers.

\subsection{Pithos fairness}

\begin{figure}[htbp]
 \centering
 \includegraphics[clip=true, viewport=15mm 30mm 270mm 175mm, width=\columnwidth]{fairness_pithos}
 \caption{The distribution of objects over peers for Pithos, when measuring the average number of objects stored during a peer's lifetime.}
 \label{fig_pithos_fairness}
\end{figure}
%
Figure \ref{fig_pithos_fairness} shows the object distribution of Pithos, with a mean and standard deviation of 31.3 and 9 objects per node respectively. The figure shows that no peers store no objects. While all peers in Pithos store objects, the standard deviation of the objects stored is higher for Pithos (9 objects) than for overlay storage (6.4 objects), which means that Pithos is not as fair as overlay storage.

\subsection{Conclusion}
What should be concluded from this section is that there does not exist a minority of peers in Pithos that store the majority of objects. All peers are required to contribute to the P2P network. It is difficult to define an empirical measure of fairness. When standard deviation is used, Pithos performs somewhat worse than overlay storage. The performance is, however, still comparable.

It should be noted that this section compared Pithos with theoretically the fairest storage system reviewed in Section \ref{storage_type_overview}. All other storage systems are expected to be as fair at best, or less fair (for example super peer storage).

\section{Scalability}

As identified in Section \ref{scalability_req}, a key requirement of P2P MMVEs is that they should be scalable. It was argued that scalability is achieved when all other requirements are met, for a large numbers of peers. The results shown thus far have been for a \emph{sufficiently scalable} system of 2500 peers.

A scalable system should not have decreased performance for larger network sizes. For a P2P MMVE state persistency architecture, a scalable system should be as reliable and responsive for smaller networks than for larger ones, while using little or no extra bandwidth.

\subsection{Experimental setup}

To show the scalability of the Pithos design and implementation, Pithos is simulated for 10,000 peers and 400 super peers, four times more peers and super peers than previously simulated. During this simulation, a total of 15.8 million storage and retrieval requests were generated and a total of 2.4 million objects were stored.

As with the previous experiments, the following configuration parameters are chosen for reasons already discussed:
%
\begin{itemize}
\item Fast group storage is used.
\item Fast group retrieval is used.
\item Simulation length of 10,000s.
\item Using the Oversim SimpleUnderlayNetwork for the physical network.
\item Exponential object lifetime with 1800s mean and 300s TTL.
\item Object sizes of 1024 bytes.
\item Generating a store and retrieve request once every 5s.
\item Using Chord as overlay.
\item Storing six object replicas.
\item No object repair is performed.
\item All requests are for local group objects.
\item Medium overlay configuration is used.
\end{itemize}


The 10,400 peer simulation setup was not shown during the previous sections, because of the resources required to complete it. The simulation requires 19 hours of run time and 14 GB of RAM on an quad core Intel Core i7, 3 GHz processor. A simulation on this scale would not have been possible using anything other than Oversim's simple underlay. The efficiency of the C++ language also provides great gains in terms of both processer and memory efficiency. Although lengthy, a 19 hour simulation time is still a feasible time to performs simulations in.

\subsection{Results}

For both cases, the average data per node from the higher layer is still measured as 4 Bps sent to Pithos and 157 Bps received from Pithos.

\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|l|l|l|}
\hline
\multirow{2}{*}{Number of peers} & \multirow{2}{*}{Module} & \multirow{2}{*}{Reliability (\%)} & Responsiveness  & \multicolumn{2}{c|}{Bandwidth (Bps)} \\
\cline{5-6}
                &        &             &  mean (var.) (s)            &in & out   \\
\hline
2600            & Overall&  99.70     &   0.192 (0.181)      & 1370&1380 \\
2600            & Group  &  97.75     &   0.134 (0.0629)     & 187&183   \\
2600            & Overlay&  91.40     &   1.760 (0.824)      & 1183&1197 \\
10,400          & Overall&  99.71     &   0.191 (0.194)      & 1647&1657 \\
10,400          & Group  &  98.19     &   0.134 (0.0674)     & 180&177   \\
10,400          & Overlay&  90.06     &   1.960 (1.005)      & 1467&1480 \\
\hline
\end{tabular}
\caption{Comparison of the reliability, responsiveness and bandwidth usage of Pithos, group storage and overlay storage for 2600 and 10400 peers respectively.}
\label{tab_pithos_scalability_results}
\end{table}
%
Table \ref{tab_pithos_scalability_results} shows the scalability of Pithos for large numbers of peers. Comparing group storage, it is evident that the reliability and responsiveness of the 2600 peer case is the same as that of the 10,400 peer case. Also of note is that group storage requires no more bandwidth for larger numbers of peers. The results show group storage to be scalable.

Overlay storage, however, fares worse both in responsiveness as well as required bandwidth.

Overall, Pithos is as reliable and responsive for 2600 peers as it is for 10,400 peers, with the exception that it uses somewhat more bandwidth, which has been shown to be as a consequence of the overlay storage not scaling as well as group storage.

This section shows that Pithos is scalable for large numbers of peers in terms of responsiveness, reliability as well as bandwidth requirements.

\section{Summary}

This section initially showed the storage and retrieval performance of Pithos, without taking into account group probability, object repair or malicious peers. Fast storage was found to be sufficiently reliable for the large responsiveness gain it added. It was found that parallel storage are both more responsive and reliable than fast storage at the cost of additional bandwidth.

Overlay storage was found to be less reliable than initially thought, when taking into account its required bandwidth. Overlay storage is, however, the only way in which a peer may acquire data from outside of its group.

The responsiveness distributions for Pithos were also presented, along with a discussion of the results. The distributions verified the methods used to implement the store and retrieve mechanisms and also showed how the underlying group and overlay storage modules relate to the overall storage performance.

It was discussed that it is important to take group probability into account when evaluating Pithos performance. By varying the group probability, it was shown that the overall performance is a weighted average of the underlying group and overlay performances.

It was shown that all peers in Pithos are required to contribute storage space to the network.

The effect of repair was shown by evaluating Pithos for various repair methods with varying node lifetimes. It was found that repair significantly increases reliability when the expected node lifetimes are small, compared to the object TTL. Repair is not required, if node lifetimes are large, compared to the object TTL.

From the evaluation of object repair, it was found that there are many factors that influence how retrieval reliability. On a basic level, retrieval reliability is directly proportional to object lifetime. From the results shown, it was found that object lifetime is, therefore, related to node lifetimes, repair rates and object TTL.

A question arises on what is acceptable reliability levels for MMVEs. There are probably types of objects in an MMVE that have to be retrieved with 100\% reliability and that for those objects, any reliability of less than 100\% is unacceptable. Firstly, it should be noted that the values shown in the above results were for specific churn rates and network parameters. It is theoretically possible to make the system reliability arbitrarily large, by exchanging bandwidth for reliability as shown. Higher update frequencies will lead to a more reliable system.

That said, it might never be possible to always achieve 100\% reliability because of network churn. This might be due to a high current churn rate in the network. Mechanisms have to be put in place in the higher level application that can handle these scenarios. A retry might be the first solution. Another would be a reporting path for failed requests. Such a system might allow for failed requests to be reported to a group and the group replication mechanisms can then dynamically increase the repair frequency to ensure all objects are always available. A study into ensuring an arbitrary level of reliability for Pithos is left for future work.

It should be possible to design a storage system with predictable levels of reliability, to ensure correct functionality of the larger system that uses the storage system. It is, therefore, of benefit to be able to predict objects lifetimes in a distributed storage system. Of greater benefit is to be able to design a storage system to ensure required levels of expected object lifetimes. This is the focus of the next chapter. Predicting object lifetimes in finite network under churn.

After the evaluation, Pithos was found to be reliable, responsive, fair and secure. Pithos is more secure than overlay storage, although a similar safe retrieval mechanism can be employed to increase the security of overlay storage. This will, however, further increase the latency present in overlay storage. Pithos is more responsive than overlay storage. Pithos is also more reliable than overlay storage, when taking into account bandwidth used. In other words, Pithos does more with a given amount of overhead than overlay storage. Pithos was found to be less fair than overlay storage, but Pithos is by no means unfair. No peers store no data and the storage distributions did not show any long tail.

It has, therefore, been shown that Pithos satisfies all requirements initially identified.
